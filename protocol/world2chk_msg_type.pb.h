// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: world2chk_msg_type.proto

#ifndef PROTOBUF_world2chk_5fmsg_5ftype_2eproto__INCLUDED
#define PROTOBUF_world2chk_5fmsg_5ftype_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace world2chk {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

class AccountChk;
class AccChkRet;
class UnServerInfo;
class GameUserStatus;
class ReqrobotPID;
class PubBindingReward;
class WestRechargeInfo;
class OrderNoChecked;
class PubRechargeRet;
class OrderCancleChecked;
class ReqExchangeOrderInsert;

// ===================================================================

class AccountChk : public ::google::protobuf::Message {
 public:
  AccountChk();
  virtual ~AccountChk();

  AccountChk(const AccountChk& from);

  inline AccountChk& operator=(const AccountChk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountChk& default_instance();

  void Swap(AccountChk* other);

  // implements Message ----------------------------------------------

  AccountChk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountChk& from);
  void MergeFrom(const AccountChk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string acc = 1;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 1;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // required int32 platform = 2;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 2;
  inline ::google::protobuf::int32 platform() const;
  inline void set_platform(::google::protobuf::int32 value);

  // required int32 serverID = 3;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIDFieldNumber = 3;
  inline ::google::protobuf::int32 serverid() const;
  inline void set_serverid(::google::protobuf::int32 value);

  // required int32 playerID = 4;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 4;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // required bool isrelogin = 5;
  inline bool has_isrelogin() const;
  inline void clear_isrelogin();
  static const int kIsreloginFieldNumber = 5;
  inline bool isrelogin() const;
  inline void set_isrelogin(bool value);

  // optional string token = 6;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 6;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:world2chk.AccountChk)
 private:
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_isrelogin();
  inline void clear_has_isrelogin();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::google::protobuf::int32 platform_;
  ::google::protobuf::int32 serverid_;
  ::google::protobuf::int32 playerid_;
  bool isrelogin_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static AccountChk* default_instance_;
};
// -------------------------------------------------------------------

class AccChkRet : public ::google::protobuf::Message {
 public:
  AccChkRet();
  virtual ~AccChkRet();

  AccChkRet(const AccChkRet& from);

  inline AccChkRet& operator=(const AccChkRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccChkRet& default_instance();

  void Swap(AccChkRet* other);

  // implements Message ----------------------------------------------

  AccChkRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccChkRet& from);
  void MergeFrom(const AccChkRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string errMsg = 1;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrMsgFieldNumber = 1;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // required string acc = 2;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 2;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // optional int32 playerID = 3;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 3;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // optional bool isrelogin = 4;
  inline bool has_isrelogin() const;
  inline void clear_isrelogin();
  static const int kIsreloginFieldNumber = 4;
  inline bool isrelogin() const;
  inline void set_isrelogin(bool value);

  // optional string userRegion = 5;
  inline bool has_userregion() const;
  inline void clear_userregion();
  static const int kUserRegionFieldNumber = 5;
  inline const ::std::string& userregion() const;
  inline void set_userregion(const ::std::string& value);
  inline void set_userregion(const char* value);
  inline void set_userregion(const char* value, size_t size);
  inline ::std::string* mutable_userregion();
  inline ::std::string* release_userregion();
  inline void set_allocated_userregion(::std::string* userregion);

  // @@protoc_insertion_point(class_scope:world2chk.AccChkRet)
 private:
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_isrelogin();
  inline void clear_has_isrelogin();
  inline void set_has_userregion();
  inline void clear_has_userregion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* errmsg_;
  ::std::string* acc_;
  ::google::protobuf::int32 playerid_;
  bool isrelogin_;
  ::std::string* userregion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static AccChkRet* default_instance_;
};
// -------------------------------------------------------------------

class UnServerInfo : public ::google::protobuf::Message {
 public:
  UnServerInfo();
  virtual ~UnServerInfo();

  UnServerInfo(const UnServerInfo& from);

  inline UnServerInfo& operator=(const UnServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnServerInfo& default_instance();

  void Swap(UnServerInfo* other);

  // implements Message ----------------------------------------------

  UnServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnServerInfo& from);
  void MergeFrom(const UnServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomAdd = 1;
  inline bool has_roomadd() const;
  inline void clear_roomadd();
  static const int kRoomAddFieldNumber = 1;
  inline const ::std::string& roomadd() const;
  inline void set_roomadd(const ::std::string& value);
  inline void set_roomadd(const char* value);
  inline void set_roomadd(const char* value, size_t size);
  inline ::std::string* mutable_roomadd();
  inline ::std::string* release_roomadd();
  inline void set_allocated_roomadd(::std::string* roomadd);

  // optional string gateAddr = 2;
  inline bool has_gateaddr() const;
  inline void clear_gateaddr();
  static const int kGateAddrFieldNumber = 2;
  inline const ::std::string& gateaddr() const;
  inline void set_gateaddr(const ::std::string& value);
  inline void set_gateaddr(const char* value);
  inline void set_gateaddr(const char* value, size_t size);
  inline ::std::string* mutable_gateaddr();
  inline ::std::string* release_gateaddr();
  inline void set_allocated_gateaddr(::std::string* gateaddr);

  // optional int32 svrLevel = 3;
  inline bool has_svrlevel() const;
  inline void clear_svrlevel();
  static const int kSvrLevelFieldNumber = 3;
  inline ::google::protobuf::int32 svrlevel() const;
  inline void set_svrlevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:world2chk.UnServerInfo)
 private:
  inline void set_has_roomadd();
  inline void clear_has_roomadd();
  inline void set_has_gateaddr();
  inline void clear_has_gateaddr();
  inline void set_has_svrlevel();
  inline void clear_has_svrlevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomadd_;
  ::std::string* gateaddr_;
  ::google::protobuf::int32 svrlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static UnServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameUserStatus : public ::google::protobuf::Message {
 public:
  GameUserStatus();
  virtual ~GameUserStatus();

  GameUserStatus(const GameUserStatus& from);

  inline GameUserStatus& operator=(const GameUserStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameUserStatus& default_instance();

  void Swap(GameUserStatus* other);

  // implements Message ----------------------------------------------

  GameUserStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameUserStatus& from);
  void MergeFrom(const GameUserStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // optional int32 gameid = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 2;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional int32 roomid = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 3;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);

  // optional int32 tableid = 4;
  inline bool has_tableid() const;
  inline void clear_tableid();
  static const int kTableidFieldNumber = 4;
  inline ::google::protobuf::int32 tableid() const;
  inline void set_tableid(::google::protobuf::int32 value);

  // optional int32 chairid = 5;
  inline bool has_chairid() const;
  inline void clear_chairid();
  static const int kChairidFieldNumber = 5;
  inline ::google::protobuf::int32 chairid() const;
  inline void set_chairid(::google::protobuf::int32 value);

  // optional int32 userstatus = 6;
  inline bool has_userstatus() const;
  inline void clear_userstatus();
  static const int kUserstatusFieldNumber = 6;
  inline ::google::protobuf::int32 userstatus() const;
  inline void set_userstatus(::google::protobuf::int32 value);

  // optional string gateAddr = 7;
  inline bool has_gateaddr() const;
  inline void clear_gateaddr();
  static const int kGateAddrFieldNumber = 7;
  inline const ::std::string& gateaddr() const;
  inline void set_gateaddr(const ::std::string& value);
  inline void set_gateaddr(const char* value);
  inline void set_gateaddr(const char* value, size_t size);
  inline ::std::string* mutable_gateaddr();
  inline ::std::string* release_gateaddr();
  inline void set_allocated_gateaddr(::std::string* gateaddr);

  // optional int32 svrLevel = 8;
  inline bool has_svrlevel() const;
  inline void clear_svrlevel();
  static const int kSvrLevelFieldNumber = 8;
  inline ::google::protobuf::int32 svrlevel() const;
  inline void set_svrlevel(::google::protobuf::int32 value);

  // optional string acc = 9;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 9;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // @@protoc_insertion_point(class_scope:world2chk.GameUserStatus)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_tableid();
  inline void clear_has_tableid();
  inline void set_has_chairid();
  inline void clear_has_chairid();
  inline void set_has_userstatus();
  inline void clear_has_userstatus();
  inline void set_has_gateaddr();
  inline void clear_has_gateaddr();
  inline void set_has_svrlevel();
  inline void clear_has_svrlevel();
  inline void set_has_acc();
  inline void clear_has_acc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 playerid_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 tableid_;
  ::google::protobuf::int32 chairid_;
  ::google::protobuf::int32 userstatus_;
  ::std::string* gateaddr_;
  ::std::string* acc_;
  ::google::protobuf::int32 svrlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static GameUserStatus* default_instance_;
};
// -------------------------------------------------------------------

class ReqrobotPID : public ::google::protobuf::Message {
 public:
  ReqrobotPID();
  virtual ~ReqrobotPID();

  ReqrobotPID(const ReqrobotPID& from);

  inline ReqrobotPID& operator=(const ReqrobotPID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqrobotPID& default_instance();

  void Swap(ReqrobotPID* other);

  // implements Message ----------------------------------------------

  ReqrobotPID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqrobotPID& from);
  void MergeFrom(const ReqrobotPID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isRobot = 1;
  inline bool has_isrobot() const;
  inline void clear_isrobot();
  static const int kIsRobotFieldNumber = 1;
  inline bool isrobot() const;
  inline void set_isrobot(bool value);

  // optional int32 pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);

  // optional int64 needGold = 3;
  inline bool has_needgold() const;
  inline void clear_needgold();
  static const int kNeedGoldFieldNumber = 3;
  inline ::google::protobuf::int64 needgold() const;
  inline void set_needgold(::google::protobuf::int64 value);

  // optional int32 needVip = 4;
  inline bool has_needvip() const;
  inline void clear_needvip();
  static const int kNeedVipFieldNumber = 4;
  inline ::google::protobuf::int32 needvip() const;
  inline void set_needvip(::google::protobuf::int32 value);

  // optional int32 gameID = 5;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 5;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional int32 remoteID = 6;
  inline bool has_remoteid() const;
  inline void clear_remoteid();
  static const int kRemoteIDFieldNumber = 6;
  inline ::google::protobuf::int32 remoteid() const;
  inline void set_remoteid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:world2chk.ReqrobotPID)
 private:
  inline void set_has_isrobot();
  inline void clear_has_isrobot();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_needgold();
  inline void clear_has_needgold();
  inline void set_has_needvip();
  inline void clear_has_needvip();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_remoteid();
  inline void clear_has_remoteid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool isrobot_;
  ::google::protobuf::int32 pid_;
  ::google::protobuf::int64 needgold_;
  ::google::protobuf::int32 needvip_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 remoteid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static ReqrobotPID* default_instance_;
};
// -------------------------------------------------------------------

class PubBindingReward : public ::google::protobuf::Message {
 public:
  PubBindingReward();
  virtual ~PubBindingReward();

  PubBindingReward(const PubBindingReward& from);

  inline PubBindingReward& operator=(const PubBindingReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PubBindingReward& default_instance();

  void Swap(PubBindingReward* other);

  // implements Message ----------------------------------------------

  PubBindingReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PubBindingReward& from);
  void MergeFrom(const PubBindingReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string acc = 1;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 1;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // optional int32 rewardValue = 2;
  inline bool has_rewardvalue() const;
  inline void clear_rewardvalue();
  static const int kRewardValueFieldNumber = 2;
  inline ::google::protobuf::int32 rewardvalue() const;
  inline void set_rewardvalue(::google::protobuf::int32 value);

  // optional string accnew = 3;
  inline bool has_accnew() const;
  inline void clear_accnew();
  static const int kAccnewFieldNumber = 3;
  inline const ::std::string& accnew() const;
  inline void set_accnew(const ::std::string& value);
  inline void set_accnew(const char* value);
  inline void set_accnew(const char* value, size_t size);
  inline ::std::string* mutable_accnew();
  inline ::std::string* release_accnew();
  inline void set_allocated_accnew(::std::string* accnew);

  // @@protoc_insertion_point(class_scope:world2chk.PubBindingReward)
 private:
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_rewardvalue();
  inline void clear_has_rewardvalue();
  inline void set_has_accnew();
  inline void clear_has_accnew();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::std::string* accnew_;
  ::google::protobuf::int32 rewardvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static PubBindingReward* default_instance_;
};
// -------------------------------------------------------------------

class WestRechargeInfo : public ::google::protobuf::Message {
 public:
  WestRechargeInfo();
  virtual ~WestRechargeInfo();

  WestRechargeInfo(const WestRechargeInfo& from);

  inline WestRechargeInfo& operator=(const WestRechargeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WestRechargeInfo& default_instance();

  void Swap(WestRechargeInfo* other);

  // implements Message ----------------------------------------------

  WestRechargeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WestRechargeInfo& from);
  void MergeFrom(const WestRechargeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string westID = 1;
  inline bool has_westid() const;
  inline void clear_westid();
  static const int kWestIDFieldNumber = 1;
  inline const ::std::string& westid() const;
  inline void set_westid(const ::std::string& value);
  inline void set_westid(const char* value);
  inline void set_westid(const char* value, size_t size);
  inline ::std::string* mutable_westid();
  inline ::std::string* release_westid();
  inline void set_allocated_westid(::std::string* westid);

  // optional string orderID = 2;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIDFieldNumber = 2;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // optional int32 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::int32 amount() const;
  inline void set_amount(::google::protobuf::int32 value);

  // optional int32 orderStatus = 4;
  inline bool has_orderstatus() const;
  inline void clear_orderstatus();
  static const int kOrderStatusFieldNumber = 4;
  inline ::google::protobuf::int32 orderstatus() const;
  inline void set_orderstatus(::google::protobuf::int32 value);

  // optional string checkSign = 5;
  inline bool has_checksign() const;
  inline void clear_checksign();
  static const int kCheckSignFieldNumber = 5;
  inline const ::std::string& checksign() const;
  inline void set_checksign(const ::std::string& value);
  inline void set_checksign(const char* value);
  inline void set_checksign(const char* value, size_t size);
  inline ::std::string* mutable_checksign();
  inline ::std::string* release_checksign();
  inline void set_allocated_checksign(::std::string* checksign);

  // optional string extInfo = 6;
  inline bool has_extinfo() const;
  inline void clear_extinfo();
  static const int kExtInfoFieldNumber = 6;
  inline const ::std::string& extinfo() const;
  inline void set_extinfo(const ::std::string& value);
  inline void set_extinfo(const char* value);
  inline void set_extinfo(const char* value, size_t size);
  inline ::std::string* mutable_extinfo();
  inline ::std::string* release_extinfo();
  inline void set_allocated_extinfo(::std::string* extinfo);

  // @@protoc_insertion_point(class_scope:world2chk.WestRechargeInfo)
 private:
  inline void set_has_westid();
  inline void clear_has_westid();
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_orderstatus();
  inline void clear_has_orderstatus();
  inline void set_has_checksign();
  inline void clear_has_checksign();
  inline void set_has_extinfo();
  inline void clear_has_extinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* westid_;
  ::std::string* orderid_;
  ::google::protobuf::int32 amount_;
  ::google::protobuf::int32 orderstatus_;
  ::std::string* checksign_;
  ::std::string* extinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static WestRechargeInfo* default_instance_;
};
// -------------------------------------------------------------------

class OrderNoChecked : public ::google::protobuf::Message {
 public:
  OrderNoChecked();
  virtual ~OrderNoChecked();

  OrderNoChecked(const OrderNoChecked& from);

  inline OrderNoChecked& operator=(const OrderNoChecked& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderNoChecked& default_instance();

  void Swap(OrderNoChecked* other);

  // implements Message ----------------------------------------------

  OrderNoChecked* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderNoChecked& from);
  void MergeFrom(const OrderNoChecked& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string orderID = 1;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIDFieldNumber = 1;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // optional int32 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::int32 amount() const;
  inline void set_amount(::google::protobuf::int32 value);

  // optional int32 payID = 3;
  inline bool has_payid() const;
  inline void clear_payid();
  static const int kPayIDFieldNumber = 3;
  inline ::google::protobuf::int32 payid() const;
  inline void set_payid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:world2chk.OrderNoChecked)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_payid();
  inline void clear_has_payid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* orderid_;
  ::google::protobuf::int32 amount_;
  ::google::protobuf::int32 payid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static OrderNoChecked* default_instance_;
};
// -------------------------------------------------------------------

class PubRechargeRet : public ::google::protobuf::Message {
 public:
  PubRechargeRet();
  virtual ~PubRechargeRet();

  PubRechargeRet(const PubRechargeRet& from);

  inline PubRechargeRet& operator=(const PubRechargeRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PubRechargeRet& default_instance();

  void Swap(PubRechargeRet* other);

  // implements Message ----------------------------------------------

  PubRechargeRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PubRechargeRet& from);
  void MergeFrom(const PubRechargeRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string acc = 1;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 1;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // repeated .world2chk.OrderNoChecked OrderList = 2;
  inline int orderlist_size() const;
  inline void clear_orderlist();
  static const int kOrderListFieldNumber = 2;
  inline const ::world2chk::OrderNoChecked& orderlist(int index) const;
  inline ::world2chk::OrderNoChecked* mutable_orderlist(int index);
  inline ::world2chk::OrderNoChecked* add_orderlist();
  inline const ::google::protobuf::RepeatedPtrField< ::world2chk::OrderNoChecked >&
      orderlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::world2chk::OrderNoChecked >*
      mutable_orderlist();

  // @@protoc_insertion_point(class_scope:world2chk.PubRechargeRet)
 private:
  inline void set_has_acc();
  inline void clear_has_acc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::google::protobuf::RepeatedPtrField< ::world2chk::OrderNoChecked > orderlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static PubRechargeRet* default_instance_;
};
// -------------------------------------------------------------------

class OrderCancleChecked : public ::google::protobuf::Message {
 public:
  OrderCancleChecked();
  virtual ~OrderCancleChecked();

  OrderCancleChecked(const OrderCancleChecked& from);

  inline OrderCancleChecked& operator=(const OrderCancleChecked& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderCancleChecked& default_instance();

  void Swap(OrderCancleChecked* other);

  // implements Message ----------------------------------------------

  OrderCancleChecked* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderCancleChecked& from);
  void MergeFrom(const OrderCancleChecked& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string orderID = 1;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIDFieldNumber = 1;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // optional int32 opType = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  inline ::google::protobuf::int32 optype() const;
  inline void set_optype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:world2chk.OrderCancleChecked)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_optype();
  inline void clear_has_optype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* orderid_;
  ::google::protobuf::int32 optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static OrderCancleChecked* default_instance_;
};
// -------------------------------------------------------------------

class ReqExchangeOrderInsert : public ::google::protobuf::Message {
 public:
  ReqExchangeOrderInsert();
  virtual ~ReqExchangeOrderInsert();

  ReqExchangeOrderInsert(const ReqExchangeOrderInsert& from);

  inline ReqExchangeOrderInsert& operator=(const ReqExchangeOrderInsert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqExchangeOrderInsert& default_instance();

  void Swap(ReqExchangeOrderInsert* other);

  // implements Message ----------------------------------------------

  ReqExchangeOrderInsert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqExchangeOrderInsert& from);
  void MergeFrom(const ReqExchangeOrderInsert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);

  // optional string acc = 2;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 2;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // optional int32 channelID = 4;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 4;
  inline ::google::protobuf::int32 channelid() const;
  inline void set_channelid(::google::protobuf::int32 value);

  // optional string deviceNum = 5;
  inline bool has_devicenum() const;
  inline void clear_devicenum();
  static const int kDeviceNumFieldNumber = 5;
  inline const ::std::string& devicenum() const;
  inline void set_devicenum(const ::std::string& value);
  inline void set_devicenum(const char* value);
  inline void set_devicenum(const char* value, size_t size);
  inline ::std::string* mutable_devicenum();
  inline ::std::string* release_devicenum();
  inline void set_allocated_devicenum(::std::string* devicenum);

  // optional int32 deviceType = 6;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 6;
  inline ::google::protobuf::int32 devicetype() const;
  inline void set_devicetype(::google::protobuf::int32 value);

  // optional int64 exchangeMoney = 7;
  inline bool has_exchangemoney() const;
  inline void clear_exchangemoney();
  static const int kExchangeMoneyFieldNumber = 7;
  inline ::google::protobuf::int64 exchangemoney() const;
  inline void set_exchangemoney(::google::protobuf::int64 value);

  // optional string aliacc = 8;
  inline bool has_aliacc() const;
  inline void clear_aliacc();
  static const int kAliaccFieldNumber = 8;
  inline const ::std::string& aliacc() const;
  inline void set_aliacc(const ::std::string& value);
  inline void set_aliacc(const char* value);
  inline void set_aliacc(const char* value, size_t size);
  inline ::std::string* mutable_aliacc();
  inline ::std::string* release_aliacc();
  inline void set_allocated_aliacc(::std::string* aliacc);

  // @@protoc_insertion_point(class_scope:world2chk.ReqExchangeOrderInsert)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_devicenum();
  inline void clear_has_devicenum();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_exchangemoney();
  inline void clear_has_exchangemoney();
  inline void set_has_aliacc();
  inline void clear_has_aliacc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::google::protobuf::int32 pid_;
  ::google::protobuf::int32 channelid_;
  ::std::string* devicenum_;
  ::google::protobuf::int64 exchangemoney_;
  ::std::string* aliacc_;
  ::google::protobuf::int32 devicetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_world2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_world2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static ReqExchangeOrderInsert* default_instance_;
};
// ===================================================================


// ===================================================================

// AccountChk

// required string acc = 1;
inline bool AccountChk::has_acc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountChk::set_has_acc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountChk::clear_has_acc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountChk::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& AccountChk::acc() const {
  return *acc_;
}
inline void AccountChk::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void AccountChk::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void AccountChk::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountChk::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* AccountChk::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountChk::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 platform = 2;
inline bool AccountChk::has_platform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountChk::set_has_platform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountChk::clear_has_platform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountChk::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::google::protobuf::int32 AccountChk::platform() const {
  return platform_;
}
inline void AccountChk::set_platform(::google::protobuf::int32 value) {
  set_has_platform();
  platform_ = value;
}

// required int32 serverID = 3;
inline bool AccountChk::has_serverid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountChk::set_has_serverid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountChk::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountChk::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 AccountChk::serverid() const {
  return serverid_;
}
inline void AccountChk::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
}

// required int32 playerID = 4;
inline bool AccountChk::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountChk::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountChk::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountChk::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 AccountChk::playerid() const {
  return playerid_;
}
inline void AccountChk::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required bool isrelogin = 5;
inline bool AccountChk::has_isrelogin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountChk::set_has_isrelogin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountChk::clear_has_isrelogin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountChk::clear_isrelogin() {
  isrelogin_ = false;
  clear_has_isrelogin();
}
inline bool AccountChk::isrelogin() const {
  return isrelogin_;
}
inline void AccountChk::set_isrelogin(bool value) {
  set_has_isrelogin();
  isrelogin_ = value;
}

// optional string token = 6;
inline bool AccountChk::has_token() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountChk::set_has_token() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountChk::clear_has_token() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountChk::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& AccountChk::token() const {
  return *token_;
}
inline void AccountChk::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AccountChk::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AccountChk::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountChk::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* AccountChk::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountChk::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccChkRet

// optional string errMsg = 1;
inline bool AccChkRet::has_errmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccChkRet::set_has_errmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccChkRet::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccChkRet::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& AccChkRet::errmsg() const {
  return *errmsg_;
}
inline void AccChkRet::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void AccChkRet::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void AccChkRet::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccChkRet::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  return errmsg_;
}
inline ::std::string* AccChkRet::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccChkRet::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string acc = 2;
inline bool AccChkRet::has_acc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccChkRet::set_has_acc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccChkRet::clear_has_acc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccChkRet::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& AccChkRet::acc() const {
  return *acc_;
}
inline void AccChkRet::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void AccChkRet::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void AccChkRet::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccChkRet::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* AccChkRet::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccChkRet::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 playerID = 3;
inline bool AccChkRet::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccChkRet::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccChkRet::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccChkRet::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 AccChkRet::playerid() const {
  return playerid_;
}
inline void AccChkRet::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional bool isrelogin = 4;
inline bool AccChkRet::has_isrelogin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccChkRet::set_has_isrelogin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccChkRet::clear_has_isrelogin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccChkRet::clear_isrelogin() {
  isrelogin_ = false;
  clear_has_isrelogin();
}
inline bool AccChkRet::isrelogin() const {
  return isrelogin_;
}
inline void AccChkRet::set_isrelogin(bool value) {
  set_has_isrelogin();
  isrelogin_ = value;
}

// optional string userRegion = 5;
inline bool AccChkRet::has_userregion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccChkRet::set_has_userregion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccChkRet::clear_has_userregion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccChkRet::clear_userregion() {
  if (userregion_ != &::google::protobuf::internal::kEmptyString) {
    userregion_->clear();
  }
  clear_has_userregion();
}
inline const ::std::string& AccChkRet::userregion() const {
  return *userregion_;
}
inline void AccChkRet::set_userregion(const ::std::string& value) {
  set_has_userregion();
  if (userregion_ == &::google::protobuf::internal::kEmptyString) {
    userregion_ = new ::std::string;
  }
  userregion_->assign(value);
}
inline void AccChkRet::set_userregion(const char* value) {
  set_has_userregion();
  if (userregion_ == &::google::protobuf::internal::kEmptyString) {
    userregion_ = new ::std::string;
  }
  userregion_->assign(value);
}
inline void AccChkRet::set_userregion(const char* value, size_t size) {
  set_has_userregion();
  if (userregion_ == &::google::protobuf::internal::kEmptyString) {
    userregion_ = new ::std::string;
  }
  userregion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccChkRet::mutable_userregion() {
  set_has_userregion();
  if (userregion_ == &::google::protobuf::internal::kEmptyString) {
    userregion_ = new ::std::string;
  }
  return userregion_;
}
inline ::std::string* AccChkRet::release_userregion() {
  clear_has_userregion();
  if (userregion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userregion_;
    userregion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccChkRet::set_allocated_userregion(::std::string* userregion) {
  if (userregion_ != &::google::protobuf::internal::kEmptyString) {
    delete userregion_;
  }
  if (userregion) {
    set_has_userregion();
    userregion_ = userregion;
  } else {
    clear_has_userregion();
    userregion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UnServerInfo

// required string roomAdd = 1;
inline bool UnServerInfo::has_roomadd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnServerInfo::set_has_roomadd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnServerInfo::clear_has_roomadd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnServerInfo::clear_roomadd() {
  if (roomadd_ != &::google::protobuf::internal::kEmptyString) {
    roomadd_->clear();
  }
  clear_has_roomadd();
}
inline const ::std::string& UnServerInfo::roomadd() const {
  return *roomadd_;
}
inline void UnServerInfo::set_roomadd(const ::std::string& value) {
  set_has_roomadd();
  if (roomadd_ == &::google::protobuf::internal::kEmptyString) {
    roomadd_ = new ::std::string;
  }
  roomadd_->assign(value);
}
inline void UnServerInfo::set_roomadd(const char* value) {
  set_has_roomadd();
  if (roomadd_ == &::google::protobuf::internal::kEmptyString) {
    roomadd_ = new ::std::string;
  }
  roomadd_->assign(value);
}
inline void UnServerInfo::set_roomadd(const char* value, size_t size) {
  set_has_roomadd();
  if (roomadd_ == &::google::protobuf::internal::kEmptyString) {
    roomadd_ = new ::std::string;
  }
  roomadd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnServerInfo::mutable_roomadd() {
  set_has_roomadd();
  if (roomadd_ == &::google::protobuf::internal::kEmptyString) {
    roomadd_ = new ::std::string;
  }
  return roomadd_;
}
inline ::std::string* UnServerInfo::release_roomadd() {
  clear_has_roomadd();
  if (roomadd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomadd_;
    roomadd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnServerInfo::set_allocated_roomadd(::std::string* roomadd) {
  if (roomadd_ != &::google::protobuf::internal::kEmptyString) {
    delete roomadd_;
  }
  if (roomadd) {
    set_has_roomadd();
    roomadd_ = roomadd;
  } else {
    clear_has_roomadd();
    roomadd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gateAddr = 2;
inline bool UnServerInfo::has_gateaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnServerInfo::set_has_gateaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnServerInfo::clear_has_gateaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnServerInfo::clear_gateaddr() {
  if (gateaddr_ != &::google::protobuf::internal::kEmptyString) {
    gateaddr_->clear();
  }
  clear_has_gateaddr();
}
inline const ::std::string& UnServerInfo::gateaddr() const {
  return *gateaddr_;
}
inline void UnServerInfo::set_gateaddr(const ::std::string& value) {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  gateaddr_->assign(value);
}
inline void UnServerInfo::set_gateaddr(const char* value) {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  gateaddr_->assign(value);
}
inline void UnServerInfo::set_gateaddr(const char* value, size_t size) {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  gateaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnServerInfo::mutable_gateaddr() {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  return gateaddr_;
}
inline ::std::string* UnServerInfo::release_gateaddr() {
  clear_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gateaddr_;
    gateaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnServerInfo::set_allocated_gateaddr(::std::string* gateaddr) {
  if (gateaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete gateaddr_;
  }
  if (gateaddr) {
    set_has_gateaddr();
    gateaddr_ = gateaddr;
  } else {
    clear_has_gateaddr();
    gateaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 svrLevel = 3;
inline bool UnServerInfo::has_svrlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnServerInfo::set_has_svrlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnServerInfo::clear_has_svrlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnServerInfo::clear_svrlevel() {
  svrlevel_ = 0;
  clear_has_svrlevel();
}
inline ::google::protobuf::int32 UnServerInfo::svrlevel() const {
  return svrlevel_;
}
inline void UnServerInfo::set_svrlevel(::google::protobuf::int32 value) {
  set_has_svrlevel();
  svrlevel_ = value;
}

// -------------------------------------------------------------------

// GameUserStatus

// optional int32 playerid = 1;
inline bool GameUserStatus::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameUserStatus::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameUserStatus::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameUserStatus::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 GameUserStatus::playerid() const {
  return playerid_;
}
inline void GameUserStatus::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional int32 gameid = 2;
inline bool GameUserStatus::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameUserStatus::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameUserStatus::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameUserStatus::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GameUserStatus::gameid() const {
  return gameid_;
}
inline void GameUserStatus::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 roomid = 3;
inline bool GameUserStatus::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameUserStatus::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameUserStatus::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameUserStatus::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 GameUserStatus::roomid() const {
  return roomid_;
}
inline void GameUserStatus::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional int32 tableid = 4;
inline bool GameUserStatus::has_tableid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameUserStatus::set_has_tableid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameUserStatus::clear_has_tableid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameUserStatus::clear_tableid() {
  tableid_ = 0;
  clear_has_tableid();
}
inline ::google::protobuf::int32 GameUserStatus::tableid() const {
  return tableid_;
}
inline void GameUserStatus::set_tableid(::google::protobuf::int32 value) {
  set_has_tableid();
  tableid_ = value;
}

// optional int32 chairid = 5;
inline bool GameUserStatus::has_chairid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameUserStatus::set_has_chairid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameUserStatus::clear_has_chairid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameUserStatus::clear_chairid() {
  chairid_ = 0;
  clear_has_chairid();
}
inline ::google::protobuf::int32 GameUserStatus::chairid() const {
  return chairid_;
}
inline void GameUserStatus::set_chairid(::google::protobuf::int32 value) {
  set_has_chairid();
  chairid_ = value;
}

// optional int32 userstatus = 6;
inline bool GameUserStatus::has_userstatus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameUserStatus::set_has_userstatus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameUserStatus::clear_has_userstatus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameUserStatus::clear_userstatus() {
  userstatus_ = 0;
  clear_has_userstatus();
}
inline ::google::protobuf::int32 GameUserStatus::userstatus() const {
  return userstatus_;
}
inline void GameUserStatus::set_userstatus(::google::protobuf::int32 value) {
  set_has_userstatus();
  userstatus_ = value;
}

// optional string gateAddr = 7;
inline bool GameUserStatus::has_gateaddr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameUserStatus::set_has_gateaddr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameUserStatus::clear_has_gateaddr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameUserStatus::clear_gateaddr() {
  if (gateaddr_ != &::google::protobuf::internal::kEmptyString) {
    gateaddr_->clear();
  }
  clear_has_gateaddr();
}
inline const ::std::string& GameUserStatus::gateaddr() const {
  return *gateaddr_;
}
inline void GameUserStatus::set_gateaddr(const ::std::string& value) {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  gateaddr_->assign(value);
}
inline void GameUserStatus::set_gateaddr(const char* value) {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  gateaddr_->assign(value);
}
inline void GameUserStatus::set_gateaddr(const char* value, size_t size) {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  gateaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameUserStatus::mutable_gateaddr() {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  return gateaddr_;
}
inline ::std::string* GameUserStatus::release_gateaddr() {
  clear_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gateaddr_;
    gateaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameUserStatus::set_allocated_gateaddr(::std::string* gateaddr) {
  if (gateaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete gateaddr_;
  }
  if (gateaddr) {
    set_has_gateaddr();
    gateaddr_ = gateaddr;
  } else {
    clear_has_gateaddr();
    gateaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 svrLevel = 8;
inline bool GameUserStatus::has_svrlevel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameUserStatus::set_has_svrlevel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameUserStatus::clear_has_svrlevel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameUserStatus::clear_svrlevel() {
  svrlevel_ = 0;
  clear_has_svrlevel();
}
inline ::google::protobuf::int32 GameUserStatus::svrlevel() const {
  return svrlevel_;
}
inline void GameUserStatus::set_svrlevel(::google::protobuf::int32 value) {
  set_has_svrlevel();
  svrlevel_ = value;
}

// optional string acc = 9;
inline bool GameUserStatus::has_acc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameUserStatus::set_has_acc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameUserStatus::clear_has_acc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameUserStatus::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& GameUserStatus::acc() const {
  return *acc_;
}
inline void GameUserStatus::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void GameUserStatus::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void GameUserStatus::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameUserStatus::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* GameUserStatus::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameUserStatus::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqrobotPID

// required bool isRobot = 1;
inline bool ReqrobotPID::has_isrobot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqrobotPID::set_has_isrobot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqrobotPID::clear_has_isrobot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqrobotPID::clear_isrobot() {
  isrobot_ = false;
  clear_has_isrobot();
}
inline bool ReqrobotPID::isrobot() const {
  return isrobot_;
}
inline void ReqrobotPID::set_isrobot(bool value) {
  set_has_isrobot();
  isrobot_ = value;
}

// optional int32 pid = 2;
inline bool ReqrobotPID::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqrobotPID::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqrobotPID::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqrobotPID::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 ReqrobotPID::pid() const {
  return pid_;
}
inline void ReqrobotPID::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}

// optional int64 needGold = 3;
inline bool ReqrobotPID::has_needgold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqrobotPID::set_has_needgold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqrobotPID::clear_has_needgold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqrobotPID::clear_needgold() {
  needgold_ = GOOGLE_LONGLONG(0);
  clear_has_needgold();
}
inline ::google::protobuf::int64 ReqrobotPID::needgold() const {
  return needgold_;
}
inline void ReqrobotPID::set_needgold(::google::protobuf::int64 value) {
  set_has_needgold();
  needgold_ = value;
}

// optional int32 needVip = 4;
inline bool ReqrobotPID::has_needvip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqrobotPID::set_has_needvip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqrobotPID::clear_has_needvip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqrobotPID::clear_needvip() {
  needvip_ = 0;
  clear_has_needvip();
}
inline ::google::protobuf::int32 ReqrobotPID::needvip() const {
  return needvip_;
}
inline void ReqrobotPID::set_needvip(::google::protobuf::int32 value) {
  set_has_needvip();
  needvip_ = value;
}

// optional int32 gameID = 5;
inline bool ReqrobotPID::has_gameid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqrobotPID::set_has_gameid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqrobotPID::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqrobotPID::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqrobotPID::gameid() const {
  return gameid_;
}
inline void ReqrobotPID::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 remoteID = 6;
inline bool ReqrobotPID::has_remoteid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqrobotPID::set_has_remoteid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqrobotPID::clear_has_remoteid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqrobotPID::clear_remoteid() {
  remoteid_ = 0;
  clear_has_remoteid();
}
inline ::google::protobuf::int32 ReqrobotPID::remoteid() const {
  return remoteid_;
}
inline void ReqrobotPID::set_remoteid(::google::protobuf::int32 value) {
  set_has_remoteid();
  remoteid_ = value;
}

// -------------------------------------------------------------------

// PubBindingReward

// optional string acc = 1;
inline bool PubBindingReward::has_acc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PubBindingReward::set_has_acc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PubBindingReward::clear_has_acc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PubBindingReward::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& PubBindingReward::acc() const {
  return *acc_;
}
inline void PubBindingReward::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void PubBindingReward::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void PubBindingReward::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PubBindingReward::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* PubBindingReward::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PubBindingReward::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 rewardValue = 2;
inline bool PubBindingReward::has_rewardvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PubBindingReward::set_has_rewardvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PubBindingReward::clear_has_rewardvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PubBindingReward::clear_rewardvalue() {
  rewardvalue_ = 0;
  clear_has_rewardvalue();
}
inline ::google::protobuf::int32 PubBindingReward::rewardvalue() const {
  return rewardvalue_;
}
inline void PubBindingReward::set_rewardvalue(::google::protobuf::int32 value) {
  set_has_rewardvalue();
  rewardvalue_ = value;
}

// optional string accnew = 3;
inline bool PubBindingReward::has_accnew() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PubBindingReward::set_has_accnew() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PubBindingReward::clear_has_accnew() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PubBindingReward::clear_accnew() {
  if (accnew_ != &::google::protobuf::internal::kEmptyString) {
    accnew_->clear();
  }
  clear_has_accnew();
}
inline const ::std::string& PubBindingReward::accnew() const {
  return *accnew_;
}
inline void PubBindingReward::set_accnew(const ::std::string& value) {
  set_has_accnew();
  if (accnew_ == &::google::protobuf::internal::kEmptyString) {
    accnew_ = new ::std::string;
  }
  accnew_->assign(value);
}
inline void PubBindingReward::set_accnew(const char* value) {
  set_has_accnew();
  if (accnew_ == &::google::protobuf::internal::kEmptyString) {
    accnew_ = new ::std::string;
  }
  accnew_->assign(value);
}
inline void PubBindingReward::set_accnew(const char* value, size_t size) {
  set_has_accnew();
  if (accnew_ == &::google::protobuf::internal::kEmptyString) {
    accnew_ = new ::std::string;
  }
  accnew_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PubBindingReward::mutable_accnew() {
  set_has_accnew();
  if (accnew_ == &::google::protobuf::internal::kEmptyString) {
    accnew_ = new ::std::string;
  }
  return accnew_;
}
inline ::std::string* PubBindingReward::release_accnew() {
  clear_has_accnew();
  if (accnew_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accnew_;
    accnew_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PubBindingReward::set_allocated_accnew(::std::string* accnew) {
  if (accnew_ != &::google::protobuf::internal::kEmptyString) {
    delete accnew_;
  }
  if (accnew) {
    set_has_accnew();
    accnew_ = accnew;
  } else {
    clear_has_accnew();
    accnew_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WestRechargeInfo

// optional string westID = 1;
inline bool WestRechargeInfo::has_westid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WestRechargeInfo::set_has_westid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WestRechargeInfo::clear_has_westid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WestRechargeInfo::clear_westid() {
  if (westid_ != &::google::protobuf::internal::kEmptyString) {
    westid_->clear();
  }
  clear_has_westid();
}
inline const ::std::string& WestRechargeInfo::westid() const {
  return *westid_;
}
inline void WestRechargeInfo::set_westid(const ::std::string& value) {
  set_has_westid();
  if (westid_ == &::google::protobuf::internal::kEmptyString) {
    westid_ = new ::std::string;
  }
  westid_->assign(value);
}
inline void WestRechargeInfo::set_westid(const char* value) {
  set_has_westid();
  if (westid_ == &::google::protobuf::internal::kEmptyString) {
    westid_ = new ::std::string;
  }
  westid_->assign(value);
}
inline void WestRechargeInfo::set_westid(const char* value, size_t size) {
  set_has_westid();
  if (westid_ == &::google::protobuf::internal::kEmptyString) {
    westid_ = new ::std::string;
  }
  westid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WestRechargeInfo::mutable_westid() {
  set_has_westid();
  if (westid_ == &::google::protobuf::internal::kEmptyString) {
    westid_ = new ::std::string;
  }
  return westid_;
}
inline ::std::string* WestRechargeInfo::release_westid() {
  clear_has_westid();
  if (westid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = westid_;
    westid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WestRechargeInfo::set_allocated_westid(::std::string* westid) {
  if (westid_ != &::google::protobuf::internal::kEmptyString) {
    delete westid_;
  }
  if (westid) {
    set_has_westid();
    westid_ = westid;
  } else {
    clear_has_westid();
    westid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string orderID = 2;
inline bool WestRechargeInfo::has_orderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WestRechargeInfo::set_has_orderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WestRechargeInfo::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WestRechargeInfo::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& WestRechargeInfo::orderid() const {
  return *orderid_;
}
inline void WestRechargeInfo::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void WestRechargeInfo::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void WestRechargeInfo::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WestRechargeInfo::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  return orderid_;
}
inline ::std::string* WestRechargeInfo::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WestRechargeInfo::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 amount = 3;
inline bool WestRechargeInfo::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WestRechargeInfo::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WestRechargeInfo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WestRechargeInfo::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline ::google::protobuf::int32 WestRechargeInfo::amount() const {
  return amount_;
}
inline void WestRechargeInfo::set_amount(::google::protobuf::int32 value) {
  set_has_amount();
  amount_ = value;
}

// optional int32 orderStatus = 4;
inline bool WestRechargeInfo::has_orderstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WestRechargeInfo::set_has_orderstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WestRechargeInfo::clear_has_orderstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WestRechargeInfo::clear_orderstatus() {
  orderstatus_ = 0;
  clear_has_orderstatus();
}
inline ::google::protobuf::int32 WestRechargeInfo::orderstatus() const {
  return orderstatus_;
}
inline void WestRechargeInfo::set_orderstatus(::google::protobuf::int32 value) {
  set_has_orderstatus();
  orderstatus_ = value;
}

// optional string checkSign = 5;
inline bool WestRechargeInfo::has_checksign() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WestRechargeInfo::set_has_checksign() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WestRechargeInfo::clear_has_checksign() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WestRechargeInfo::clear_checksign() {
  if (checksign_ != &::google::protobuf::internal::kEmptyString) {
    checksign_->clear();
  }
  clear_has_checksign();
}
inline const ::std::string& WestRechargeInfo::checksign() const {
  return *checksign_;
}
inline void WestRechargeInfo::set_checksign(const ::std::string& value) {
  set_has_checksign();
  if (checksign_ == &::google::protobuf::internal::kEmptyString) {
    checksign_ = new ::std::string;
  }
  checksign_->assign(value);
}
inline void WestRechargeInfo::set_checksign(const char* value) {
  set_has_checksign();
  if (checksign_ == &::google::protobuf::internal::kEmptyString) {
    checksign_ = new ::std::string;
  }
  checksign_->assign(value);
}
inline void WestRechargeInfo::set_checksign(const char* value, size_t size) {
  set_has_checksign();
  if (checksign_ == &::google::protobuf::internal::kEmptyString) {
    checksign_ = new ::std::string;
  }
  checksign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WestRechargeInfo::mutable_checksign() {
  set_has_checksign();
  if (checksign_ == &::google::protobuf::internal::kEmptyString) {
    checksign_ = new ::std::string;
  }
  return checksign_;
}
inline ::std::string* WestRechargeInfo::release_checksign() {
  clear_has_checksign();
  if (checksign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = checksign_;
    checksign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WestRechargeInfo::set_allocated_checksign(::std::string* checksign) {
  if (checksign_ != &::google::protobuf::internal::kEmptyString) {
    delete checksign_;
  }
  if (checksign) {
    set_has_checksign();
    checksign_ = checksign;
  } else {
    clear_has_checksign();
    checksign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extInfo = 6;
inline bool WestRechargeInfo::has_extinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WestRechargeInfo::set_has_extinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WestRechargeInfo::clear_has_extinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WestRechargeInfo::clear_extinfo() {
  if (extinfo_ != &::google::protobuf::internal::kEmptyString) {
    extinfo_->clear();
  }
  clear_has_extinfo();
}
inline const ::std::string& WestRechargeInfo::extinfo() const {
  return *extinfo_;
}
inline void WestRechargeInfo::set_extinfo(const ::std::string& value) {
  set_has_extinfo();
  if (extinfo_ == &::google::protobuf::internal::kEmptyString) {
    extinfo_ = new ::std::string;
  }
  extinfo_->assign(value);
}
inline void WestRechargeInfo::set_extinfo(const char* value) {
  set_has_extinfo();
  if (extinfo_ == &::google::protobuf::internal::kEmptyString) {
    extinfo_ = new ::std::string;
  }
  extinfo_->assign(value);
}
inline void WestRechargeInfo::set_extinfo(const char* value, size_t size) {
  set_has_extinfo();
  if (extinfo_ == &::google::protobuf::internal::kEmptyString) {
    extinfo_ = new ::std::string;
  }
  extinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WestRechargeInfo::mutable_extinfo() {
  set_has_extinfo();
  if (extinfo_ == &::google::protobuf::internal::kEmptyString) {
    extinfo_ = new ::std::string;
  }
  return extinfo_;
}
inline ::std::string* WestRechargeInfo::release_extinfo() {
  clear_has_extinfo();
  if (extinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extinfo_;
    extinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WestRechargeInfo::set_allocated_extinfo(::std::string* extinfo) {
  if (extinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete extinfo_;
  }
  if (extinfo) {
    set_has_extinfo();
    extinfo_ = extinfo;
  } else {
    clear_has_extinfo();
    extinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OrderNoChecked

// optional string orderID = 1;
inline bool OrderNoChecked::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderNoChecked::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderNoChecked::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderNoChecked::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& OrderNoChecked::orderid() const {
  return *orderid_;
}
inline void OrderNoChecked::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void OrderNoChecked::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void OrderNoChecked::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderNoChecked::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  return orderid_;
}
inline ::std::string* OrderNoChecked::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderNoChecked::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 amount = 2;
inline bool OrderNoChecked::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderNoChecked::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderNoChecked::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderNoChecked::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline ::google::protobuf::int32 OrderNoChecked::amount() const {
  return amount_;
}
inline void OrderNoChecked::set_amount(::google::protobuf::int32 value) {
  set_has_amount();
  amount_ = value;
}

// optional int32 payID = 3;
inline bool OrderNoChecked::has_payid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderNoChecked::set_has_payid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderNoChecked::clear_has_payid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderNoChecked::clear_payid() {
  payid_ = 0;
  clear_has_payid();
}
inline ::google::protobuf::int32 OrderNoChecked::payid() const {
  return payid_;
}
inline void OrderNoChecked::set_payid(::google::protobuf::int32 value) {
  set_has_payid();
  payid_ = value;
}

// -------------------------------------------------------------------

// PubRechargeRet

// optional string acc = 1;
inline bool PubRechargeRet::has_acc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PubRechargeRet::set_has_acc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PubRechargeRet::clear_has_acc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PubRechargeRet::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& PubRechargeRet::acc() const {
  return *acc_;
}
inline void PubRechargeRet::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void PubRechargeRet::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void PubRechargeRet::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PubRechargeRet::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* PubRechargeRet::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PubRechargeRet::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .world2chk.OrderNoChecked OrderList = 2;
inline int PubRechargeRet::orderlist_size() const {
  return orderlist_.size();
}
inline void PubRechargeRet::clear_orderlist() {
  orderlist_.Clear();
}
inline const ::world2chk::OrderNoChecked& PubRechargeRet::orderlist(int index) const {
  return orderlist_.Get(index);
}
inline ::world2chk::OrderNoChecked* PubRechargeRet::mutable_orderlist(int index) {
  return orderlist_.Mutable(index);
}
inline ::world2chk::OrderNoChecked* PubRechargeRet::add_orderlist() {
  return orderlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::world2chk::OrderNoChecked >&
PubRechargeRet::orderlist() const {
  return orderlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::world2chk::OrderNoChecked >*
PubRechargeRet::mutable_orderlist() {
  return &orderlist_;
}

// -------------------------------------------------------------------

// OrderCancleChecked

// optional string orderID = 1;
inline bool OrderCancleChecked::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderCancleChecked::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderCancleChecked::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderCancleChecked::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& OrderCancleChecked::orderid() const {
  return *orderid_;
}
inline void OrderCancleChecked::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void OrderCancleChecked::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void OrderCancleChecked::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancleChecked::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  return orderid_;
}
inline ::std::string* OrderCancleChecked::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancleChecked::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 opType = 2;
inline bool OrderCancleChecked::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderCancleChecked::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderCancleChecked::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderCancleChecked::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::google::protobuf::int32 OrderCancleChecked::optype() const {
  return optype_;
}
inline void OrderCancleChecked::set_optype(::google::protobuf::int32 value) {
  set_has_optype();
  optype_ = value;
}

// -------------------------------------------------------------------

// ReqExchangeOrderInsert

// optional int32 pid = 1;
inline bool ReqExchangeOrderInsert::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqExchangeOrderInsert::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqExchangeOrderInsert::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqExchangeOrderInsert::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 ReqExchangeOrderInsert::pid() const {
  return pid_;
}
inline void ReqExchangeOrderInsert::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}

// optional string acc = 2;
inline bool ReqExchangeOrderInsert::has_acc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqExchangeOrderInsert::set_has_acc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqExchangeOrderInsert::clear_has_acc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqExchangeOrderInsert::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& ReqExchangeOrderInsert::acc() const {
  return *acc_;
}
inline void ReqExchangeOrderInsert::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void ReqExchangeOrderInsert::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void ReqExchangeOrderInsert::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqExchangeOrderInsert::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* ReqExchangeOrderInsert::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqExchangeOrderInsert::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 channelID = 4;
inline bool ReqExchangeOrderInsert::has_channelid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqExchangeOrderInsert::set_has_channelid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqExchangeOrderInsert::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqExchangeOrderInsert::clear_channelid() {
  channelid_ = 0;
  clear_has_channelid();
}
inline ::google::protobuf::int32 ReqExchangeOrderInsert::channelid() const {
  return channelid_;
}
inline void ReqExchangeOrderInsert::set_channelid(::google::protobuf::int32 value) {
  set_has_channelid();
  channelid_ = value;
}

// optional string deviceNum = 5;
inline bool ReqExchangeOrderInsert::has_devicenum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqExchangeOrderInsert::set_has_devicenum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqExchangeOrderInsert::clear_has_devicenum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqExchangeOrderInsert::clear_devicenum() {
  if (devicenum_ != &::google::protobuf::internal::kEmptyString) {
    devicenum_->clear();
  }
  clear_has_devicenum();
}
inline const ::std::string& ReqExchangeOrderInsert::devicenum() const {
  return *devicenum_;
}
inline void ReqExchangeOrderInsert::set_devicenum(const ::std::string& value) {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  devicenum_->assign(value);
}
inline void ReqExchangeOrderInsert::set_devicenum(const char* value) {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  devicenum_->assign(value);
}
inline void ReqExchangeOrderInsert::set_devicenum(const char* value, size_t size) {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  devicenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqExchangeOrderInsert::mutable_devicenum() {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  return devicenum_;
}
inline ::std::string* ReqExchangeOrderInsert::release_devicenum() {
  clear_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicenum_;
    devicenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqExchangeOrderInsert::set_allocated_devicenum(::std::string* devicenum) {
  if (devicenum_ != &::google::protobuf::internal::kEmptyString) {
    delete devicenum_;
  }
  if (devicenum) {
    set_has_devicenum();
    devicenum_ = devicenum;
  } else {
    clear_has_devicenum();
    devicenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 deviceType = 6;
inline bool ReqExchangeOrderInsert::has_devicetype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqExchangeOrderInsert::set_has_devicetype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqExchangeOrderInsert::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqExchangeOrderInsert::clear_devicetype() {
  devicetype_ = 0;
  clear_has_devicetype();
}
inline ::google::protobuf::int32 ReqExchangeOrderInsert::devicetype() const {
  return devicetype_;
}
inline void ReqExchangeOrderInsert::set_devicetype(::google::protobuf::int32 value) {
  set_has_devicetype();
  devicetype_ = value;
}

// optional int64 exchangeMoney = 7;
inline bool ReqExchangeOrderInsert::has_exchangemoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqExchangeOrderInsert::set_has_exchangemoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqExchangeOrderInsert::clear_has_exchangemoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqExchangeOrderInsert::clear_exchangemoney() {
  exchangemoney_ = GOOGLE_LONGLONG(0);
  clear_has_exchangemoney();
}
inline ::google::protobuf::int64 ReqExchangeOrderInsert::exchangemoney() const {
  return exchangemoney_;
}
inline void ReqExchangeOrderInsert::set_exchangemoney(::google::protobuf::int64 value) {
  set_has_exchangemoney();
  exchangemoney_ = value;
}

// optional string aliacc = 8;
inline bool ReqExchangeOrderInsert::has_aliacc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqExchangeOrderInsert::set_has_aliacc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqExchangeOrderInsert::clear_has_aliacc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqExchangeOrderInsert::clear_aliacc() {
  if (aliacc_ != &::google::protobuf::internal::kEmptyString) {
    aliacc_->clear();
  }
  clear_has_aliacc();
}
inline const ::std::string& ReqExchangeOrderInsert::aliacc() const {
  return *aliacc_;
}
inline void ReqExchangeOrderInsert::set_aliacc(const ::std::string& value) {
  set_has_aliacc();
  if (aliacc_ == &::google::protobuf::internal::kEmptyString) {
    aliacc_ = new ::std::string;
  }
  aliacc_->assign(value);
}
inline void ReqExchangeOrderInsert::set_aliacc(const char* value) {
  set_has_aliacc();
  if (aliacc_ == &::google::protobuf::internal::kEmptyString) {
    aliacc_ = new ::std::string;
  }
  aliacc_->assign(value);
}
inline void ReqExchangeOrderInsert::set_aliacc(const char* value, size_t size) {
  set_has_aliacc();
  if (aliacc_ == &::google::protobuf::internal::kEmptyString) {
    aliacc_ = new ::std::string;
  }
  aliacc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqExchangeOrderInsert::mutable_aliacc() {
  set_has_aliacc();
  if (aliacc_ == &::google::protobuf::internal::kEmptyString) {
    aliacc_ = new ::std::string;
  }
  return aliacc_;
}
inline ::std::string* ReqExchangeOrderInsert::release_aliacc() {
  clear_has_aliacc();
  if (aliacc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = aliacc_;
    aliacc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqExchangeOrderInsert::set_allocated_aliacc(::std::string* aliacc) {
  if (aliacc_ != &::google::protobuf::internal::kEmptyString) {
    delete aliacc_;
  }
  if (aliacc) {
    set_has_aliacc();
    aliacc_ = aliacc;
  } else {
    clear_has_aliacc();
    aliacc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace world2chk

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_world2chk_5fmsg_5ftype_2eproto__INCLUDED
