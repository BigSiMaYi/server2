// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: login2chk_msg_type.proto

#ifndef PROTOBUF_login2chk_5fmsg_5ftype_2eproto__INCLUDED
#define PROTOBUF_login2chk_5fmsg_5ftype_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace login2chk {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

class C2LHeartBeat;
class L2CHeartBeatRet;
class UserLogin;
class RoomInfo;
class UserLoginRet;
class RequestSMSCode;
class Req2WebSMSRet;
class UserPhoneBinding;
class UserAliPayBinding;
class RetrievePwd;
class BindingRet;
class Ch2LBindingRet;
class ReqWorldToken;
class ReqWorldTokenRet;
class RequestChargeOrder;
class ChargeRet;
class CheckChargeRet;

// ===================================================================

class C2LHeartBeat : public ::google::protobuf::Message {
 public:
  C2LHeartBeat();
  virtual ~C2LHeartBeat();

  C2LHeartBeat(const C2LHeartBeat& from);

  inline C2LHeartBeat& operator=(const C2LHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const C2LHeartBeat& default_instance();

  void Swap(C2LHeartBeat* other);

  // implements Message ----------------------------------------------

  C2LHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2LHeartBeat& from);
  void MergeFrom(const C2LHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 8];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:login2chk.C2LHeartBeat)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 packet_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static C2LHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class L2CHeartBeatRet : public ::google::protobuf::Message {
 public:
  L2CHeartBeatRet();
  virtual ~L2CHeartBeatRet();

  L2CHeartBeatRet(const L2CHeartBeatRet& from);

  inline L2CHeartBeatRet& operator=(const L2CHeartBeatRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const L2CHeartBeatRet& default_instance();

  void Swap(L2CHeartBeatRet* other);

  // implements Message ----------------------------------------------

  L2CHeartBeatRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const L2CHeartBeatRet& from);
  void MergeFrom(const L2CHeartBeatRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 9];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:login2chk.L2CHeartBeatRet)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 packet_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static L2CHeartBeatRet* default_instance_;
};
// -------------------------------------------------------------------

class UserLogin : public ::google::protobuf::Message {
 public:
  UserLogin();
  virtual ~UserLogin();

  UserLogin(const UserLogin& from);

  inline UserLogin& operator=(const UserLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLogin& default_instance();

  void Swap(UserLogin* other);

  // implements Message ----------------------------------------------

  UserLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLogin& from);
  void MergeFrom(const UserLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 1003];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // optional string acc = 2;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 2;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // optional string pwd = 3;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 3;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // optional int32 channelID = 4;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 4;
  inline ::google::protobuf::int32 channelid() const;
  inline void set_channelid(::google::protobuf::int32 value);

  // required string deviceNum = 5;
  inline bool has_devicenum() const;
  inline void clear_devicenum();
  static const int kDeviceNumFieldNumber = 5;
  inline const ::std::string& devicenum() const;
  inline void set_devicenum(const ::std::string& value);
  inline void set_devicenum(const char* value);
  inline void set_devicenum(const char* value, size_t size);
  inline ::std::string* mutable_devicenum();
  inline ::std::string* release_devicenum();
  inline void set_allocated_devicenum(::std::string* devicenum);

  // optional int32 platfrom = 6;
  inline bool has_platfrom() const;
  inline void clear_platfrom();
  static const int kPlatfromFieldNumber = 6;
  inline ::google::protobuf::int32 platfrom() const;
  inline void set_platfrom(::google::protobuf::int32 value);

  // optional int32 referral = 7;
  inline bool has_referral() const;
  inline void clear_referral();
  static const int kReferralFieldNumber = 7;
  inline ::google::protobuf::int32 referral() const;
  inline void set_referral(::google::protobuf::int32 value);

  // optional int32 loginType = 8;
  inline bool has_logintype() const;
  inline void clear_logintype();
  static const int kLoginTypeFieldNumber = 8;
  inline ::google::protobuf::int32 logintype() const;
  inline void set_logintype(::google::protobuf::int32 value);

  // optional string thirdEx = 9;
  inline bool has_thirdex() const;
  inline void clear_thirdex();
  static const int kThirdExFieldNumber = 9;
  inline const ::std::string& thirdex() const;
  inline void set_thirdex(const ::std::string& value);
  inline void set_thirdex(const char* value);
  inline void set_thirdex(const char* value, size_t size);
  inline ::std::string* mutable_thirdex();
  inline ::std::string* release_thirdex();
  inline void set_allocated_thirdex(::std::string* thirdex);

  // @@protoc_insertion_point(class_scope:login2chk.UserLogin)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_devicenum();
  inline void clear_has_devicenum();
  inline void set_has_platfrom();
  inline void clear_has_platfrom();
  inline void set_has_referral();
  inline void clear_has_referral();
  inline void set_has_logintype();
  inline void clear_has_logintype();
  inline void set_has_thirdex();
  inline void clear_has_thirdex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::google::protobuf::int32 packet_id_;
  ::google::protobuf::int32 channelid_;
  ::std::string* pwd_;
  ::std::string* devicenum_;
  ::google::protobuf::int32 platfrom_;
  ::google::protobuf::int32 referral_;
  ::std::string* thirdex_;
  ::google::protobuf::int32 logintype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static UserLogin* default_instance_;
};
// -------------------------------------------------------------------

class RoomInfo : public ::google::protobuf::Message {
 public:
  RoomInfo();
  virtual ~RoomInfo();

  RoomInfo(const RoomInfo& from);

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInfo& default_instance();

  void Swap(RoomInfo* other);

  // implements Message ----------------------------------------------

  RoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 gameGenre = 1;
  inline bool has_gamegenre() const;
  inline void clear_gamegenre();
  static const int kGameGenreFieldNumber = 1;
  inline ::google::protobuf::int32 gamegenre() const;
  inline void set_gamegenre(::google::protobuf::int32 value);

  // required int32 gameType = 2;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGameTypeFieldNumber = 2;
  inline ::google::protobuf::int32 gametype() const;
  inline void set_gametype(::google::protobuf::int32 value);

  // optional string roomAddr = 3;
  inline bool has_roomaddr() const;
  inline void clear_roomaddr();
  static const int kRoomAddrFieldNumber = 3;
  inline const ::std::string& roomaddr() const;
  inline void set_roomaddr(const ::std::string& value);
  inline void set_roomaddr(const char* value);
  inline void set_roomaddr(const char* value, size_t size);
  inline ::std::string* mutable_roomaddr();
  inline ::std::string* release_roomaddr();
  inline void set_allocated_roomaddr(::std::string* roomaddr);

  // optional int32 roomType = 4;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 4;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // optional int32 roomID = 5;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 5;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);

  // optional int32 onlineCnt = 6;
  inline bool has_onlinecnt() const;
  inline void clear_onlinecnt();
  static const int kOnlineCntFieldNumber = 6;
  inline ::google::protobuf::int32 onlinecnt() const;
  inline void set_onlinecnt(::google::protobuf::int32 value);

  // required string gateAddr = 7;
  inline bool has_gateaddr() const;
  inline void clear_gateaddr();
  static const int kGateAddrFieldNumber = 7;
  inline const ::std::string& gateaddr() const;
  inline void set_gateaddr(const ::std::string& value);
  inline void set_gateaddr(const char* value);
  inline void set_gateaddr(const char* value, size_t size);
  inline ::std::string* mutable_gateaddr();
  inline ::std::string* release_gateaddr();
  inline void set_allocated_gateaddr(::std::string* gateaddr);

  // optional int32 svrLevel = 8;
  inline bool has_svrlevel() const;
  inline void clear_svrlevel();
  static const int kSvrLevelFieldNumber = 8;
  inline ::google::protobuf::int32 svrlevel() const;
  inline void set_svrlevel(::google::protobuf::int32 value);

  // optional int32 gameVer = 9;
  inline bool has_gamever() const;
  inline void clear_gamever();
  static const int kGameVerFieldNumber = 9;
  inline ::google::protobuf::int32 gamever() const;
  inline void set_gamever(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:login2chk.RoomInfo)
 private:
  inline void set_has_gamegenre();
  inline void clear_has_gamegenre();
  inline void set_has_gametype();
  inline void clear_has_gametype();
  inline void set_has_roomaddr();
  inline void clear_has_roomaddr();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_onlinecnt();
  inline void clear_has_onlinecnt();
  inline void set_has_gateaddr();
  inline void clear_has_gateaddr();
  inline void set_has_svrlevel();
  inline void clear_has_svrlevel();
  inline void set_has_gamever();
  inline void clear_has_gamever();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gamegenre_;
  ::google::protobuf::int32 gametype_;
  ::std::string* roomaddr_;
  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 roomid_;
  ::std::string* gateaddr_;
  ::google::protobuf::int32 onlinecnt_;
  ::google::protobuf::int32 svrlevel_;
  ::google::protobuf::int32 gamever_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginRet : public ::google::protobuf::Message {
 public:
  UserLoginRet();
  virtual ~UserLoginRet();

  UserLoginRet(const UserLoginRet& from);

  inline UserLoginRet& operator=(const UserLoginRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLoginRet& default_instance();

  void Swap(UserLoginRet* other);

  // implements Message ----------------------------------------------

  UserLoginRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLoginRet& from);
  void MergeFrom(const UserLoginRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 1004];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string acc = 3;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 3;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // optional string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required bool isrelogin = 5;
  inline bool has_isrelogin() const;
  inline void clear_isrelogin();
  static const int kIsreloginFieldNumber = 5;
  inline bool isrelogin() const;
  inline void set_isrelogin(bool value);

  // repeated .login2chk.RoomInfo content = 6;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 6;
  inline const ::login2chk::RoomInfo& content(int index) const;
  inline ::login2chk::RoomInfo* mutable_content(int index);
  inline ::login2chk::RoomInfo* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::login2chk::RoomInfo >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::login2chk::RoomInfo >*
      mutable_content();

  // optional bytes original = 7;
  inline bool has_original() const;
  inline void clear_original();
  static const int kOriginalFieldNumber = 7;
  inline const ::std::string& original() const;
  inline void set_original(const ::std::string& value);
  inline void set_original(const char* value);
  inline void set_original(const void* value, size_t size);
  inline ::std::string* mutable_original();
  inline ::std::string* release_original();
  inline void set_allocated_original(::std::string* original);

  // optional string regionArea = 8;
  inline bool has_regionarea() const;
  inline void clear_regionarea();
  static const int kRegionAreaFieldNumber = 8;
  inline const ::std::string& regionarea() const;
  inline void set_regionarea(const ::std::string& value);
  inline void set_regionarea(const char* value);
  inline void set_regionarea(const char* value, size_t size);
  inline ::std::string* mutable_regionarea();
  inline ::std::string* release_regionarea();
  inline void set_allocated_regionarea(::std::string* regionarea);

  // optional bool isTourist = 9;
  inline bool has_istourist() const;
  inline void clear_istourist();
  static const int kIsTouristFieldNumber = 9;
  inline bool istourist() const;
  inline void set_istourist(bool value);

  // optional string phoneNum = 10;
  inline bool has_phonenum() const;
  inline void clear_phonenum();
  static const int kPhoneNumFieldNumber = 10;
  inline const ::std::string& phonenum() const;
  inline void set_phonenum(const ::std::string& value);
  inline void set_phonenum(const char* value);
  inline void set_phonenum(const char* value, size_t size);
  inline ::std::string* mutable_phonenum();
  inline ::std::string* release_phonenum();
  inline void set_allocated_phonenum(::std::string* phonenum);

  // optional string alipayAcc = 11;
  inline bool has_alipayacc() const;
  inline void clear_alipayacc();
  static const int kAlipayAccFieldNumber = 11;
  inline const ::std::string& alipayacc() const;
  inline void set_alipayacc(const ::std::string& value);
  inline void set_alipayacc(const char* value);
  inline void set_alipayacc(const char* value, size_t size);
  inline ::std::string* mutable_alipayacc();
  inline ::std::string* release_alipayacc();
  inline void set_allocated_alipayacc(::std::string* alipayacc);

  // optional string realName = 12;
  inline bool has_realname() const;
  inline void clear_realname();
  static const int kRealNameFieldNumber = 12;
  inline const ::std::string& realname() const;
  inline void set_realname(const ::std::string& value);
  inline void set_realname(const char* value);
  inline void set_realname(const char* value, size_t size);
  inline ::std::string* mutable_realname();
  inline ::std::string* release_realname();
  inline void set_allocated_realname(::std::string* realname);

  // optional int64 bindingReward = 13;
  inline bool has_bindingreward() const;
  inline void clear_bindingreward();
  static const int kBindingRewardFieldNumber = 13;
  inline ::google::protobuf::int64 bindingreward() const;
  inline void set_bindingreward(::google::protobuf::int64 value);

  // optional string defaultGate = 14;
  inline bool has_defaultgate() const;
  inline void clear_defaultgate();
  static const int kDefaultGateFieldNumber = 14;
  inline const ::std::string& defaultgate() const;
  inline void set_defaultgate(const ::std::string& value);
  inline void set_defaultgate(const char* value);
  inline void set_defaultgate(const char* value, size_t size);
  inline ::std::string* mutable_defaultgate();
  inline ::std::string* release_defaultgate();
  inline void set_allocated_defaultgate(::std::string* defaultgate);

  // optional string errorMsg = 15;
  inline bool has_errormsg() const;
  inline void clear_errormsg();
  static const int kErrorMsgFieldNumber = 15;
  inline const ::std::string& errormsg() const;
  inline void set_errormsg(const ::std::string& value);
  inline void set_errormsg(const char* value);
  inline void set_errormsg(const char* value, size_t size);
  inline ::std::string* mutable_errormsg();
  inline ::std::string* release_errormsg();
  inline void set_allocated_errormsg(::std::string* errormsg);

  // @@protoc_insertion_point(class_scope:login2chk.UserLoginRet)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_isrelogin();
  inline void clear_has_isrelogin();
  inline void set_has_original();
  inline void clear_has_original();
  inline void set_has_regionarea();
  inline void clear_has_regionarea();
  inline void set_has_istourist();
  inline void clear_has_istourist();
  inline void set_has_phonenum();
  inline void clear_has_phonenum();
  inline void set_has_alipayacc();
  inline void clear_has_alipayacc();
  inline void set_has_realname();
  inline void clear_has_realname();
  inline void set_has_bindingreward();
  inline void clear_has_bindingreward();
  inline void set_has_defaultgate();
  inline void clear_has_defaultgate();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 packet_id_;
  ::google::protobuf::int32 result_;
  ::std::string* acc_;
  ::std::string* token_;
  ::google::protobuf::RepeatedPtrField< ::login2chk::RoomInfo > content_;
  ::std::string* original_;
  ::std::string* regionarea_;
  ::std::string* phonenum_;
  ::std::string* alipayacc_;
  ::std::string* realname_;
  ::google::protobuf::int64 bindingreward_;
  ::std::string* defaultgate_;
  ::std::string* errormsg_;
  bool isrelogin_;
  bool istourist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static UserLoginRet* default_instance_;
};
// -------------------------------------------------------------------

class RequestSMSCode : public ::google::protobuf::Message {
 public:
  RequestSMSCode();
  virtual ~RequestSMSCode();

  RequestSMSCode(const RequestSMSCode& from);

  inline RequestSMSCode& operator=(const RequestSMSCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestSMSCode& default_instance();

  void Swap(RequestSMSCode* other);

  // implements Message ----------------------------------------------

  RequestSMSCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestSMSCode& from);
  void MergeFrom(const RequestSMSCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 1007];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // required string acc = 2;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 2;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // required string phoneNum = 3;
  inline bool has_phonenum() const;
  inline void clear_phonenum();
  static const int kPhoneNumFieldNumber = 3;
  inline const ::std::string& phonenum() const;
  inline void set_phonenum(const ::std::string& value);
  inline void set_phonenum(const char* value);
  inline void set_phonenum(const char* value, size_t size);
  inline ::std::string* mutable_phonenum();
  inline ::std::string* release_phonenum();
  inline void set_allocated_phonenum(::std::string* phonenum);

  // optional int32 smsType = 4;
  inline bool has_smstype() const;
  inline void clear_smstype();
  static const int kSmsTypeFieldNumber = 4;
  inline ::google::protobuf::int32 smstype() const;
  inline void set_smstype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:login2chk.RequestSMSCode)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_phonenum();
  inline void clear_has_phonenum();
  inline void set_has_smstype();
  inline void clear_has_smstype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::google::protobuf::int32 packet_id_;
  ::google::protobuf::int32 smstype_;
  ::std::string* phonenum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static RequestSMSCode* default_instance_;
};
// -------------------------------------------------------------------

class Req2WebSMSRet : public ::google::protobuf::Message {
 public:
  Req2WebSMSRet();
  virtual ~Req2WebSMSRet();

  Req2WebSMSRet(const Req2WebSMSRet& from);

  inline Req2WebSMSRet& operator=(const Req2WebSMSRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Req2WebSMSRet& default_instance();

  void Swap(Req2WebSMSRet* other);

  // implements Message ----------------------------------------------

  Req2WebSMSRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Req2WebSMSRet& from);
  void MergeFrom(const Req2WebSMSRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 reqSMSCode = 1;
  inline bool has_reqsmscode() const;
  inline void clear_reqsmscode();
  static const int kReqSMSCodeFieldNumber = 1;
  inline ::google::protobuf::int32 reqsmscode() const;
  inline void set_reqsmscode(::google::protobuf::int32 value);

  // required bytes info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const void* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:login2chk.Req2WebSMSRet)
 private:
  inline void set_has_reqsmscode();
  inline void clear_has_reqsmscode();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* info_;
  ::google::protobuf::int32 reqsmscode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static Req2WebSMSRet* default_instance_;
};
// -------------------------------------------------------------------

class UserPhoneBinding : public ::google::protobuf::Message {
 public:
  UserPhoneBinding();
  virtual ~UserPhoneBinding();

  UserPhoneBinding(const UserPhoneBinding& from);

  inline UserPhoneBinding& operator=(const UserPhoneBinding& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPhoneBinding& default_instance();

  void Swap(UserPhoneBinding* other);

  // implements Message ----------------------------------------------

  UserPhoneBinding* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserPhoneBinding& from);
  void MergeFrom(const UserPhoneBinding& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 1009];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // required string acc = 2;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 2;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // optional string pwd = 3;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 3;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // required string deviceNum = 4;
  inline bool has_devicenum() const;
  inline void clear_devicenum();
  static const int kDeviceNumFieldNumber = 4;
  inline const ::std::string& devicenum() const;
  inline void set_devicenum(const ::std::string& value);
  inline void set_devicenum(const char* value);
  inline void set_devicenum(const char* value, size_t size);
  inline ::std::string* mutable_devicenum();
  inline ::std::string* release_devicenum();
  inline void set_allocated_devicenum(::std::string* devicenum);

  // optional string phoneNum = 5;
  inline bool has_phonenum() const;
  inline void clear_phonenum();
  static const int kPhoneNumFieldNumber = 5;
  inline const ::std::string& phonenum() const;
  inline void set_phonenum(const ::std::string& value);
  inline void set_phonenum(const char* value);
  inline void set_phonenum(const char* value, size_t size);
  inline ::std::string* mutable_phonenum();
  inline ::std::string* release_phonenum();
  inline void set_allocated_phonenum(::std::string* phonenum);

  // required int32 smsCode = 6;
  inline bool has_smscode() const;
  inline void clear_smscode();
  static const int kSmsCodeFieldNumber = 6;
  inline ::google::protobuf::int32 smscode() const;
  inline void set_smscode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:login2chk.UserPhoneBinding)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_devicenum();
  inline void clear_has_devicenum();
  inline void set_has_phonenum();
  inline void clear_has_phonenum();
  inline void set_has_smscode();
  inline void clear_has_smscode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::std::string* pwd_;
  ::google::protobuf::int32 packet_id_;
  ::google::protobuf::int32 smscode_;
  ::std::string* devicenum_;
  ::std::string* phonenum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static UserPhoneBinding* default_instance_;
};
// -------------------------------------------------------------------

class UserAliPayBinding : public ::google::protobuf::Message {
 public:
  UserAliPayBinding();
  virtual ~UserAliPayBinding();

  UserAliPayBinding(const UserAliPayBinding& from);

  inline UserAliPayBinding& operator=(const UserAliPayBinding& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserAliPayBinding& default_instance();

  void Swap(UserAliPayBinding* other);

  // implements Message ----------------------------------------------

  UserAliPayBinding* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserAliPayBinding& from);
  void MergeFrom(const UserAliPayBinding& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 1011];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // required string acc = 2;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 2;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // optional string alipayAcc = 3;
  inline bool has_alipayacc() const;
  inline void clear_alipayacc();
  static const int kAlipayAccFieldNumber = 3;
  inline const ::std::string& alipayacc() const;
  inline void set_alipayacc(const ::std::string& value);
  inline void set_alipayacc(const char* value);
  inline void set_alipayacc(const char* value, size_t size);
  inline ::std::string* mutable_alipayacc();
  inline ::std::string* release_alipayacc();
  inline void set_allocated_alipayacc(::std::string* alipayacc);

  // optional string realName = 4;
  inline bool has_realname() const;
  inline void clear_realname();
  static const int kRealNameFieldNumber = 4;
  inline const ::std::string& realname() const;
  inline void set_realname(const ::std::string& value);
  inline void set_realname(const char* value);
  inline void set_realname(const char* value, size_t size);
  inline ::std::string* mutable_realname();
  inline ::std::string* release_realname();
  inline void set_allocated_realname(::std::string* realname);

  // @@protoc_insertion_point(class_scope:login2chk.UserAliPayBinding)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_alipayacc();
  inline void clear_has_alipayacc();
  inline void set_has_realname();
  inline void clear_has_realname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::std::string* alipayacc_;
  ::std::string* realname_;
  ::google::protobuf::int32 packet_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static UserAliPayBinding* default_instance_;
};
// -------------------------------------------------------------------

class RetrievePwd : public ::google::protobuf::Message {
 public:
  RetrievePwd();
  virtual ~RetrievePwd();

  RetrievePwd(const RetrievePwd& from);

  inline RetrievePwd& operator=(const RetrievePwd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetrievePwd& default_instance();

  void Swap(RetrievePwd* other);

  // implements Message ----------------------------------------------

  RetrievePwd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetrievePwd& from);
  void MergeFrom(const RetrievePwd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 1013];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // required string acc = 2;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 2;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // required string phoneNum = 3;
  inline bool has_phonenum() const;
  inline void clear_phonenum();
  static const int kPhoneNumFieldNumber = 3;
  inline const ::std::string& phonenum() const;
  inline void set_phonenum(const ::std::string& value);
  inline void set_phonenum(const char* value);
  inline void set_phonenum(const char* value, size_t size);
  inline ::std::string* mutable_phonenum();
  inline ::std::string* release_phonenum();
  inline void set_allocated_phonenum(::std::string* phonenum);

  // required int32 smsNum = 4;
  inline bool has_smsnum() const;
  inline void clear_smsnum();
  static const int kSmsNumFieldNumber = 4;
  inline ::google::protobuf::int32 smsnum() const;
  inline void set_smsnum(::google::protobuf::int32 value);

  // required string newPwd = 5;
  inline bool has_newpwd() const;
  inline void clear_newpwd();
  static const int kNewPwdFieldNumber = 5;
  inline const ::std::string& newpwd() const;
  inline void set_newpwd(const ::std::string& value);
  inline void set_newpwd(const char* value);
  inline void set_newpwd(const char* value, size_t size);
  inline ::std::string* mutable_newpwd();
  inline ::std::string* release_newpwd();
  inline void set_allocated_newpwd(::std::string* newpwd);

  // @@protoc_insertion_point(class_scope:login2chk.RetrievePwd)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_phonenum();
  inline void clear_has_phonenum();
  inline void set_has_smsnum();
  inline void clear_has_smsnum();
  inline void set_has_newpwd();
  inline void clear_has_newpwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::google::protobuf::int32 packet_id_;
  ::google::protobuf::int32 smsnum_;
  ::std::string* phonenum_;
  ::std::string* newpwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static RetrievePwd* default_instance_;
};
// -------------------------------------------------------------------

class BindingRet : public ::google::protobuf::Message {
 public:
  BindingRet();
  virtual ~BindingRet();

  BindingRet(const BindingRet& from);

  inline BindingRet& operator=(const BindingRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindingRet& default_instance();

  void Swap(BindingRet* other);

  // implements Message ----------------------------------------------

  BindingRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BindingRet& from);
  void MergeFrom(const BindingRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 1012];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 optype = 3;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOptypeFieldNumber = 3;
  inline ::google::protobuf::int32 optype() const;
  inline void set_optype(::google::protobuf::int32 value);

  // required int32 errorNum = 4;
  inline bool has_errornum() const;
  inline void clear_errornum();
  static const int kErrorNumFieldNumber = 4;
  inline ::google::protobuf::int32 errornum() const;
  inline void set_errornum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:login2chk.BindingRet)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_errornum();
  inline void clear_has_errornum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 packet_id_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 optype_;
  ::google::protobuf::int32 errornum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static BindingRet* default_instance_;
};
// -------------------------------------------------------------------

class Ch2LBindingRet : public ::google::protobuf::Message {
 public:
  Ch2LBindingRet();
  virtual ~Ch2LBindingRet();

  Ch2LBindingRet(const Ch2LBindingRet& from);

  inline Ch2LBindingRet& operator=(const Ch2LBindingRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ch2LBindingRet& default_instance();

  void Swap(Ch2LBindingRet* other);

  // implements Message ----------------------------------------------

  Ch2LBindingRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ch2LBindingRet& from);
  void MergeFrom(const Ch2LBindingRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes upbInfo = 1;
  inline bool has_upbinfo() const;
  inline void clear_upbinfo();
  static const int kUpbInfoFieldNumber = 1;
  inline const ::std::string& upbinfo() const;
  inline void set_upbinfo(const ::std::string& value);
  inline void set_upbinfo(const char* value);
  inline void set_upbinfo(const void* value, size_t size);
  inline ::std::string* mutable_upbinfo();
  inline ::std::string* release_upbinfo();
  inline void set_allocated_upbinfo(::std::string* upbinfo);

  // required bytes brInfo = 2;
  inline bool has_brinfo() const;
  inline void clear_brinfo();
  static const int kBrInfoFieldNumber = 2;
  inline const ::std::string& brinfo() const;
  inline void set_brinfo(const ::std::string& value);
  inline void set_brinfo(const char* value);
  inline void set_brinfo(const void* value, size_t size);
  inline ::std::string* mutable_brinfo();
  inline ::std::string* release_brinfo();
  inline void set_allocated_brinfo(::std::string* brinfo);

  // @@protoc_insertion_point(class_scope:login2chk.Ch2LBindingRet)
 private:
  inline void set_has_upbinfo();
  inline void clear_has_upbinfo();
  inline void set_has_brinfo();
  inline void clear_has_brinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* upbinfo_;
  ::std::string* brinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static Ch2LBindingRet* default_instance_;
};
// -------------------------------------------------------------------

class ReqWorldToken : public ::google::protobuf::Message {
 public:
  ReqWorldToken();
  virtual ~ReqWorldToken();

  ReqWorldToken(const ReqWorldToken& from);

  inline ReqWorldToken& operator=(const ReqWorldToken& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqWorldToken& default_instance();

  void Swap(ReqWorldToken* other);

  // implements Message ----------------------------------------------

  ReqWorldToken* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqWorldToken& from);
  void MergeFrom(const ReqWorldToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 1019];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // optional string acc = 2;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 2;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // @@protoc_insertion_point(class_scope:login2chk.ReqWorldToken)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();
  inline void set_has_acc();
  inline void clear_has_acc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::google::protobuf::int32 packet_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static ReqWorldToken* default_instance_;
};
// -------------------------------------------------------------------

class ReqWorldTokenRet : public ::google::protobuf::Message {
 public:
  ReqWorldTokenRet();
  virtual ~ReqWorldTokenRet();

  ReqWorldTokenRet(const ReqWorldTokenRet& from);

  inline ReqWorldTokenRet& operator=(const ReqWorldTokenRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqWorldTokenRet& default_instance();

  void Swap(ReqWorldTokenRet* other);

  // implements Message ----------------------------------------------

  ReqWorldTokenRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqWorldTokenRet& from);
  void MergeFrom(const ReqWorldTokenRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 1020];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // optional string acc = 2;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 2;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // optional string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:login2chk.ReqWorldTokenRet)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::std::string* token_;
  ::google::protobuf::int32 packet_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static ReqWorldTokenRet* default_instance_;
};
// -------------------------------------------------------------------

class RequestChargeOrder : public ::google::protobuf::Message {
 public:
  RequestChargeOrder();
  virtual ~RequestChargeOrder();

  RequestChargeOrder(const RequestChargeOrder& from);

  inline RequestChargeOrder& operator=(const RequestChargeOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestChargeOrder& default_instance();

  void Swap(RequestChargeOrder* other);

  // implements Message ----------------------------------------------

  RequestChargeOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestChargeOrder& from);
  void MergeFrom(const RequestChargeOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 packet_id = 1 [default = 1018];
  inline bool has_packet_id() const;
  inline void clear_packet_id();
  static const int kPacketIdFieldNumber = 1;
  inline ::google::protobuf::int32 packet_id() const;
  inline void set_packet_id(::google::protobuf::int32 value);

  // required string acc = 2;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 2;
  inline const ::std::string& acc() const;
  inline void set_acc(const ::std::string& value);
  inline void set_acc(const char* value);
  inline void set_acc(const char* value, size_t size);
  inline ::std::string* mutable_acc();
  inline ::std::string* release_acc();
  inline void set_allocated_acc(::std::string* acc);

  // optional int32 channelID = 3;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 3;
  inline ::google::protobuf::int32 channelid() const;
  inline void set_channelid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:login2chk.RequestChargeOrder)
 private:
  inline void set_has_packet_id();
  inline void clear_has_packet_id();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_channelid();
  inline void clear_has_channelid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acc_;
  ::google::protobuf::int32 packet_id_;
  ::google::protobuf::int32 channelid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static RequestChargeOrder* default_instance_;
};
// -------------------------------------------------------------------

class ChargeRet : public ::google::protobuf::Message {
 public:
  ChargeRet();
  virtual ~ChargeRet();

  ChargeRet(const ChargeRet& from);

  inline ChargeRet& operator=(const ChargeRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChargeRet& default_instance();

  void Swap(ChargeRet* other);

  // implements Message ----------------------------------------------

  ChargeRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChargeRet& from);
  void MergeFrom(const ChargeRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:login2chk.ChargeRet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static ChargeRet* default_instance_;
};
// -------------------------------------------------------------------

class CheckChargeRet : public ::google::protobuf::Message {
 public:
  CheckChargeRet();
  virtual ~CheckChargeRet();

  CheckChargeRet(const CheckChargeRet& from);

  inline CheckChargeRet& operator=(const CheckChargeRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckChargeRet& default_instance();

  void Swap(CheckChargeRet* other);

  // implements Message ----------------------------------------------

  CheckChargeRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckChargeRet& from);
  void MergeFrom(const CheckChargeRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:login2chk.CheckChargeRet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_AssignDesc_login2chk_5fmsg_5ftype_2eproto();
  friend void protobuf_ShutdownFile_login2chk_5fmsg_5ftype_2eproto();

  void InitAsDefaultInstance();
  static CheckChargeRet* default_instance_;
};
// ===================================================================


// ===================================================================

// C2LHeartBeat

// optional int32 packet_id = 1 [default = 8];
inline bool C2LHeartBeat::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2LHeartBeat::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2LHeartBeat::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2LHeartBeat::clear_packet_id() {
  packet_id_ = 8;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 C2LHeartBeat::packet_id() const {
  return packet_id_;
}
inline void C2LHeartBeat::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// -------------------------------------------------------------------

// L2CHeartBeatRet

// optional int32 packet_id = 1 [default = 9];
inline bool L2CHeartBeatRet::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void L2CHeartBeatRet::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void L2CHeartBeatRet::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void L2CHeartBeatRet::clear_packet_id() {
  packet_id_ = 9;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 L2CHeartBeatRet::packet_id() const {
  return packet_id_;
}
inline void L2CHeartBeatRet::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// -------------------------------------------------------------------

// UserLogin

// optional int32 packet_id = 1 [default = 1003];
inline bool UserLogin::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLogin::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLogin::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLogin::clear_packet_id() {
  packet_id_ = 1003;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 UserLogin::packet_id() const {
  return packet_id_;
}
inline void UserLogin::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// optional string acc = 2;
inline bool UserLogin::has_acc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLogin::set_has_acc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLogin::clear_has_acc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLogin::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& UserLogin::acc() const {
  return *acc_;
}
inline void UserLogin::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void UserLogin::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void UserLogin::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogin::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* UserLogin::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogin::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pwd = 3;
inline bool UserLogin::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserLogin::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserLogin::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserLogin::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& UserLogin::pwd() const {
  return *pwd_;
}
inline void UserLogin::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void UserLogin::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void UserLogin::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogin::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* UserLogin::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogin::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 channelID = 4;
inline bool UserLogin::has_channelid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserLogin::set_has_channelid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserLogin::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserLogin::clear_channelid() {
  channelid_ = 0;
  clear_has_channelid();
}
inline ::google::protobuf::int32 UserLogin::channelid() const {
  return channelid_;
}
inline void UserLogin::set_channelid(::google::protobuf::int32 value) {
  set_has_channelid();
  channelid_ = value;
}

// required string deviceNum = 5;
inline bool UserLogin::has_devicenum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserLogin::set_has_devicenum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserLogin::clear_has_devicenum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserLogin::clear_devicenum() {
  if (devicenum_ != &::google::protobuf::internal::kEmptyString) {
    devicenum_->clear();
  }
  clear_has_devicenum();
}
inline const ::std::string& UserLogin::devicenum() const {
  return *devicenum_;
}
inline void UserLogin::set_devicenum(const ::std::string& value) {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  devicenum_->assign(value);
}
inline void UserLogin::set_devicenum(const char* value) {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  devicenum_->assign(value);
}
inline void UserLogin::set_devicenum(const char* value, size_t size) {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  devicenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogin::mutable_devicenum() {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  return devicenum_;
}
inline ::std::string* UserLogin::release_devicenum() {
  clear_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicenum_;
    devicenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogin::set_allocated_devicenum(::std::string* devicenum) {
  if (devicenum_ != &::google::protobuf::internal::kEmptyString) {
    delete devicenum_;
  }
  if (devicenum) {
    set_has_devicenum();
    devicenum_ = devicenum;
  } else {
    clear_has_devicenum();
    devicenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 platfrom = 6;
inline bool UserLogin::has_platfrom() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserLogin::set_has_platfrom() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserLogin::clear_has_platfrom() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserLogin::clear_platfrom() {
  platfrom_ = 0;
  clear_has_platfrom();
}
inline ::google::protobuf::int32 UserLogin::platfrom() const {
  return platfrom_;
}
inline void UserLogin::set_platfrom(::google::protobuf::int32 value) {
  set_has_platfrom();
  platfrom_ = value;
}

// optional int32 referral = 7;
inline bool UserLogin::has_referral() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserLogin::set_has_referral() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserLogin::clear_has_referral() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserLogin::clear_referral() {
  referral_ = 0;
  clear_has_referral();
}
inline ::google::protobuf::int32 UserLogin::referral() const {
  return referral_;
}
inline void UserLogin::set_referral(::google::protobuf::int32 value) {
  set_has_referral();
  referral_ = value;
}

// optional int32 loginType = 8;
inline bool UserLogin::has_logintype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserLogin::set_has_logintype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserLogin::clear_has_logintype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserLogin::clear_logintype() {
  logintype_ = 0;
  clear_has_logintype();
}
inline ::google::protobuf::int32 UserLogin::logintype() const {
  return logintype_;
}
inline void UserLogin::set_logintype(::google::protobuf::int32 value) {
  set_has_logintype();
  logintype_ = value;
}

// optional string thirdEx = 9;
inline bool UserLogin::has_thirdex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserLogin::set_has_thirdex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserLogin::clear_has_thirdex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserLogin::clear_thirdex() {
  if (thirdex_ != &::google::protobuf::internal::kEmptyString) {
    thirdex_->clear();
  }
  clear_has_thirdex();
}
inline const ::std::string& UserLogin::thirdex() const {
  return *thirdex_;
}
inline void UserLogin::set_thirdex(const ::std::string& value) {
  set_has_thirdex();
  if (thirdex_ == &::google::protobuf::internal::kEmptyString) {
    thirdex_ = new ::std::string;
  }
  thirdex_->assign(value);
}
inline void UserLogin::set_thirdex(const char* value) {
  set_has_thirdex();
  if (thirdex_ == &::google::protobuf::internal::kEmptyString) {
    thirdex_ = new ::std::string;
  }
  thirdex_->assign(value);
}
inline void UserLogin::set_thirdex(const char* value, size_t size) {
  set_has_thirdex();
  if (thirdex_ == &::google::protobuf::internal::kEmptyString) {
    thirdex_ = new ::std::string;
  }
  thirdex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogin::mutable_thirdex() {
  set_has_thirdex();
  if (thirdex_ == &::google::protobuf::internal::kEmptyString) {
    thirdex_ = new ::std::string;
  }
  return thirdex_;
}
inline ::std::string* UserLogin::release_thirdex() {
  clear_has_thirdex();
  if (thirdex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thirdex_;
    thirdex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogin::set_allocated_thirdex(::std::string* thirdex) {
  if (thirdex_ != &::google::protobuf::internal::kEmptyString) {
    delete thirdex_;
  }
  if (thirdex) {
    set_has_thirdex();
    thirdex_ = thirdex;
  } else {
    clear_has_thirdex();
    thirdex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoomInfo

// optional int32 gameGenre = 1;
inline bool RoomInfo::has_gamegenre() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInfo::set_has_gamegenre() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInfo::clear_has_gamegenre() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInfo::clear_gamegenre() {
  gamegenre_ = 0;
  clear_has_gamegenre();
}
inline ::google::protobuf::int32 RoomInfo::gamegenre() const {
  return gamegenre_;
}
inline void RoomInfo::set_gamegenre(::google::protobuf::int32 value) {
  set_has_gamegenre();
  gamegenre_ = value;
}

// required int32 gameType = 2;
inline bool RoomInfo::has_gametype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInfo::set_has_gametype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInfo::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInfo::clear_gametype() {
  gametype_ = 0;
  clear_has_gametype();
}
inline ::google::protobuf::int32 RoomInfo::gametype() const {
  return gametype_;
}
inline void RoomInfo::set_gametype(::google::protobuf::int32 value) {
  set_has_gametype();
  gametype_ = value;
}

// optional string roomAddr = 3;
inline bool RoomInfo::has_roomaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomInfo::set_has_roomaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomInfo::clear_has_roomaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomInfo::clear_roomaddr() {
  if (roomaddr_ != &::google::protobuf::internal::kEmptyString) {
    roomaddr_->clear();
  }
  clear_has_roomaddr();
}
inline const ::std::string& RoomInfo::roomaddr() const {
  return *roomaddr_;
}
inline void RoomInfo::set_roomaddr(const ::std::string& value) {
  set_has_roomaddr();
  if (roomaddr_ == &::google::protobuf::internal::kEmptyString) {
    roomaddr_ = new ::std::string;
  }
  roomaddr_->assign(value);
}
inline void RoomInfo::set_roomaddr(const char* value) {
  set_has_roomaddr();
  if (roomaddr_ == &::google::protobuf::internal::kEmptyString) {
    roomaddr_ = new ::std::string;
  }
  roomaddr_->assign(value);
}
inline void RoomInfo::set_roomaddr(const char* value, size_t size) {
  set_has_roomaddr();
  if (roomaddr_ == &::google::protobuf::internal::kEmptyString) {
    roomaddr_ = new ::std::string;
  }
  roomaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_roomaddr() {
  set_has_roomaddr();
  if (roomaddr_ == &::google::protobuf::internal::kEmptyString) {
    roomaddr_ = new ::std::string;
  }
  return roomaddr_;
}
inline ::std::string* RoomInfo::release_roomaddr() {
  clear_has_roomaddr();
  if (roomaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomaddr_;
    roomaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_roomaddr(::std::string* roomaddr) {
  if (roomaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete roomaddr_;
  }
  if (roomaddr) {
    set_has_roomaddr();
    roomaddr_ = roomaddr;
  } else {
    clear_has_roomaddr();
    roomaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 roomType = 4;
inline bool RoomInfo::has_roomtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomInfo::set_has_roomtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomInfo::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomInfo::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 RoomInfo::roomtype() const {
  return roomtype_;
}
inline void RoomInfo::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// optional int32 roomID = 5;
inline bool RoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomInfo::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 RoomInfo::roomid() const {
  return roomid_;
}
inline void RoomInfo::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional int32 onlineCnt = 6;
inline bool RoomInfo::has_onlinecnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomInfo::set_has_onlinecnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomInfo::clear_has_onlinecnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomInfo::clear_onlinecnt() {
  onlinecnt_ = 0;
  clear_has_onlinecnt();
}
inline ::google::protobuf::int32 RoomInfo::onlinecnt() const {
  return onlinecnt_;
}
inline void RoomInfo::set_onlinecnt(::google::protobuf::int32 value) {
  set_has_onlinecnt();
  onlinecnt_ = value;
}

// required string gateAddr = 7;
inline bool RoomInfo::has_gateaddr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomInfo::set_has_gateaddr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomInfo::clear_has_gateaddr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomInfo::clear_gateaddr() {
  if (gateaddr_ != &::google::protobuf::internal::kEmptyString) {
    gateaddr_->clear();
  }
  clear_has_gateaddr();
}
inline const ::std::string& RoomInfo::gateaddr() const {
  return *gateaddr_;
}
inline void RoomInfo::set_gateaddr(const ::std::string& value) {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  gateaddr_->assign(value);
}
inline void RoomInfo::set_gateaddr(const char* value) {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  gateaddr_->assign(value);
}
inline void RoomInfo::set_gateaddr(const char* value, size_t size) {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  gateaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_gateaddr() {
  set_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    gateaddr_ = new ::std::string;
  }
  return gateaddr_;
}
inline ::std::string* RoomInfo::release_gateaddr() {
  clear_has_gateaddr();
  if (gateaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gateaddr_;
    gateaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_gateaddr(::std::string* gateaddr) {
  if (gateaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete gateaddr_;
  }
  if (gateaddr) {
    set_has_gateaddr();
    gateaddr_ = gateaddr;
  } else {
    clear_has_gateaddr();
    gateaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 svrLevel = 8;
inline bool RoomInfo::has_svrlevel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomInfo::set_has_svrlevel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomInfo::clear_has_svrlevel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomInfo::clear_svrlevel() {
  svrlevel_ = 0;
  clear_has_svrlevel();
}
inline ::google::protobuf::int32 RoomInfo::svrlevel() const {
  return svrlevel_;
}
inline void RoomInfo::set_svrlevel(::google::protobuf::int32 value) {
  set_has_svrlevel();
  svrlevel_ = value;
}

// optional int32 gameVer = 9;
inline bool RoomInfo::has_gamever() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoomInfo::set_has_gamever() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoomInfo::clear_has_gamever() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoomInfo::clear_gamever() {
  gamever_ = 0;
  clear_has_gamever();
}
inline ::google::protobuf::int32 RoomInfo::gamever() const {
  return gamever_;
}
inline void RoomInfo::set_gamever(::google::protobuf::int32 value) {
  set_has_gamever();
  gamever_ = value;
}

// -------------------------------------------------------------------

// UserLoginRet

// optional int32 packet_id = 1 [default = 1004];
inline bool UserLoginRet::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginRet::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginRet::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginRet::clear_packet_id() {
  packet_id_ = 1004;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 UserLoginRet::packet_id() const {
  return packet_id_;
}
inline void UserLoginRet::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// optional int32 result = 2;
inline bool UserLoginRet::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginRet::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginRet::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginRet::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UserLoginRet::result() const {
  return result_;
}
inline void UserLoginRet::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string acc = 3;
inline bool UserLoginRet::has_acc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserLoginRet::set_has_acc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserLoginRet::clear_has_acc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserLoginRet::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& UserLoginRet::acc() const {
  return *acc_;
}
inline void UserLoginRet::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void UserLoginRet::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void UserLoginRet::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRet::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* UserLoginRet::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginRet::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 4;
inline bool UserLoginRet::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserLoginRet::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserLoginRet::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserLoginRet::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UserLoginRet::token() const {
  return *token_;
}
inline void UserLoginRet::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserLoginRet::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserLoginRet::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRet::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* UserLoginRet::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginRet::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool isrelogin = 5;
inline bool UserLoginRet::has_isrelogin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserLoginRet::set_has_isrelogin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserLoginRet::clear_has_isrelogin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserLoginRet::clear_isrelogin() {
  isrelogin_ = false;
  clear_has_isrelogin();
}
inline bool UserLoginRet::isrelogin() const {
  return isrelogin_;
}
inline void UserLoginRet::set_isrelogin(bool value) {
  set_has_isrelogin();
  isrelogin_ = value;
}

// repeated .login2chk.RoomInfo content = 6;
inline int UserLoginRet::content_size() const {
  return content_.size();
}
inline void UserLoginRet::clear_content() {
  content_.Clear();
}
inline const ::login2chk::RoomInfo& UserLoginRet::content(int index) const {
  return content_.Get(index);
}
inline ::login2chk::RoomInfo* UserLoginRet::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::login2chk::RoomInfo* UserLoginRet::add_content() {
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::login2chk::RoomInfo >&
UserLoginRet::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::login2chk::RoomInfo >*
UserLoginRet::mutable_content() {
  return &content_;
}

// optional bytes original = 7;
inline bool UserLoginRet::has_original() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserLoginRet::set_has_original() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserLoginRet::clear_has_original() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserLoginRet::clear_original() {
  if (original_ != &::google::protobuf::internal::kEmptyString) {
    original_->clear();
  }
  clear_has_original();
}
inline const ::std::string& UserLoginRet::original() const {
  return *original_;
}
inline void UserLoginRet::set_original(const ::std::string& value) {
  set_has_original();
  if (original_ == &::google::protobuf::internal::kEmptyString) {
    original_ = new ::std::string;
  }
  original_->assign(value);
}
inline void UserLoginRet::set_original(const char* value) {
  set_has_original();
  if (original_ == &::google::protobuf::internal::kEmptyString) {
    original_ = new ::std::string;
  }
  original_->assign(value);
}
inline void UserLoginRet::set_original(const void* value, size_t size) {
  set_has_original();
  if (original_ == &::google::protobuf::internal::kEmptyString) {
    original_ = new ::std::string;
  }
  original_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRet::mutable_original() {
  set_has_original();
  if (original_ == &::google::protobuf::internal::kEmptyString) {
    original_ = new ::std::string;
  }
  return original_;
}
inline ::std::string* UserLoginRet::release_original() {
  clear_has_original();
  if (original_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = original_;
    original_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginRet::set_allocated_original(::std::string* original) {
  if (original_ != &::google::protobuf::internal::kEmptyString) {
    delete original_;
  }
  if (original) {
    set_has_original();
    original_ = original;
  } else {
    clear_has_original();
    original_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string regionArea = 8;
inline bool UserLoginRet::has_regionarea() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserLoginRet::set_has_regionarea() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserLoginRet::clear_has_regionarea() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserLoginRet::clear_regionarea() {
  if (regionarea_ != &::google::protobuf::internal::kEmptyString) {
    regionarea_->clear();
  }
  clear_has_regionarea();
}
inline const ::std::string& UserLoginRet::regionarea() const {
  return *regionarea_;
}
inline void UserLoginRet::set_regionarea(const ::std::string& value) {
  set_has_regionarea();
  if (regionarea_ == &::google::protobuf::internal::kEmptyString) {
    regionarea_ = new ::std::string;
  }
  regionarea_->assign(value);
}
inline void UserLoginRet::set_regionarea(const char* value) {
  set_has_regionarea();
  if (regionarea_ == &::google::protobuf::internal::kEmptyString) {
    regionarea_ = new ::std::string;
  }
  regionarea_->assign(value);
}
inline void UserLoginRet::set_regionarea(const char* value, size_t size) {
  set_has_regionarea();
  if (regionarea_ == &::google::protobuf::internal::kEmptyString) {
    regionarea_ = new ::std::string;
  }
  regionarea_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRet::mutable_regionarea() {
  set_has_regionarea();
  if (regionarea_ == &::google::protobuf::internal::kEmptyString) {
    regionarea_ = new ::std::string;
  }
  return regionarea_;
}
inline ::std::string* UserLoginRet::release_regionarea() {
  clear_has_regionarea();
  if (regionarea_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = regionarea_;
    regionarea_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginRet::set_allocated_regionarea(::std::string* regionarea) {
  if (regionarea_ != &::google::protobuf::internal::kEmptyString) {
    delete regionarea_;
  }
  if (regionarea) {
    set_has_regionarea();
    regionarea_ = regionarea;
  } else {
    clear_has_regionarea();
    regionarea_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isTourist = 9;
inline bool UserLoginRet::has_istourist() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserLoginRet::set_has_istourist() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserLoginRet::clear_has_istourist() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserLoginRet::clear_istourist() {
  istourist_ = false;
  clear_has_istourist();
}
inline bool UserLoginRet::istourist() const {
  return istourist_;
}
inline void UserLoginRet::set_istourist(bool value) {
  set_has_istourist();
  istourist_ = value;
}

// optional string phoneNum = 10;
inline bool UserLoginRet::has_phonenum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserLoginRet::set_has_phonenum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserLoginRet::clear_has_phonenum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserLoginRet::clear_phonenum() {
  if (phonenum_ != &::google::protobuf::internal::kEmptyString) {
    phonenum_->clear();
  }
  clear_has_phonenum();
}
inline const ::std::string& UserLoginRet::phonenum() const {
  return *phonenum_;
}
inline void UserLoginRet::set_phonenum(const ::std::string& value) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(value);
}
inline void UserLoginRet::set_phonenum(const char* value) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(value);
}
inline void UserLoginRet::set_phonenum(const char* value, size_t size) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRet::mutable_phonenum() {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  return phonenum_;
}
inline ::std::string* UserLoginRet::release_phonenum() {
  clear_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phonenum_;
    phonenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginRet::set_allocated_phonenum(::std::string* phonenum) {
  if (phonenum_ != &::google::protobuf::internal::kEmptyString) {
    delete phonenum_;
  }
  if (phonenum) {
    set_has_phonenum();
    phonenum_ = phonenum;
  } else {
    clear_has_phonenum();
    phonenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alipayAcc = 11;
inline bool UserLoginRet::has_alipayacc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserLoginRet::set_has_alipayacc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserLoginRet::clear_has_alipayacc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserLoginRet::clear_alipayacc() {
  if (alipayacc_ != &::google::protobuf::internal::kEmptyString) {
    alipayacc_->clear();
  }
  clear_has_alipayacc();
}
inline const ::std::string& UserLoginRet::alipayacc() const {
  return *alipayacc_;
}
inline void UserLoginRet::set_alipayacc(const ::std::string& value) {
  set_has_alipayacc();
  if (alipayacc_ == &::google::protobuf::internal::kEmptyString) {
    alipayacc_ = new ::std::string;
  }
  alipayacc_->assign(value);
}
inline void UserLoginRet::set_alipayacc(const char* value) {
  set_has_alipayacc();
  if (alipayacc_ == &::google::protobuf::internal::kEmptyString) {
    alipayacc_ = new ::std::string;
  }
  alipayacc_->assign(value);
}
inline void UserLoginRet::set_alipayacc(const char* value, size_t size) {
  set_has_alipayacc();
  if (alipayacc_ == &::google::protobuf::internal::kEmptyString) {
    alipayacc_ = new ::std::string;
  }
  alipayacc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRet::mutable_alipayacc() {
  set_has_alipayacc();
  if (alipayacc_ == &::google::protobuf::internal::kEmptyString) {
    alipayacc_ = new ::std::string;
  }
  return alipayacc_;
}
inline ::std::string* UserLoginRet::release_alipayacc() {
  clear_has_alipayacc();
  if (alipayacc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alipayacc_;
    alipayacc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginRet::set_allocated_alipayacc(::std::string* alipayacc) {
  if (alipayacc_ != &::google::protobuf::internal::kEmptyString) {
    delete alipayacc_;
  }
  if (alipayacc) {
    set_has_alipayacc();
    alipayacc_ = alipayacc;
  } else {
    clear_has_alipayacc();
    alipayacc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string realName = 12;
inline bool UserLoginRet::has_realname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserLoginRet::set_has_realname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserLoginRet::clear_has_realname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserLoginRet::clear_realname() {
  if (realname_ != &::google::protobuf::internal::kEmptyString) {
    realname_->clear();
  }
  clear_has_realname();
}
inline const ::std::string& UserLoginRet::realname() const {
  return *realname_;
}
inline void UserLoginRet::set_realname(const ::std::string& value) {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  realname_->assign(value);
}
inline void UserLoginRet::set_realname(const char* value) {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  realname_->assign(value);
}
inline void UserLoginRet::set_realname(const char* value, size_t size) {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  realname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRet::mutable_realname() {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  return realname_;
}
inline ::std::string* UserLoginRet::release_realname() {
  clear_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = realname_;
    realname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginRet::set_allocated_realname(::std::string* realname) {
  if (realname_ != &::google::protobuf::internal::kEmptyString) {
    delete realname_;
  }
  if (realname) {
    set_has_realname();
    realname_ = realname;
  } else {
    clear_has_realname();
    realname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 bindingReward = 13;
inline bool UserLoginRet::has_bindingreward() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserLoginRet::set_has_bindingreward() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserLoginRet::clear_has_bindingreward() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserLoginRet::clear_bindingreward() {
  bindingreward_ = GOOGLE_LONGLONG(0);
  clear_has_bindingreward();
}
inline ::google::protobuf::int64 UserLoginRet::bindingreward() const {
  return bindingreward_;
}
inline void UserLoginRet::set_bindingreward(::google::protobuf::int64 value) {
  set_has_bindingreward();
  bindingreward_ = value;
}

// optional string defaultGate = 14;
inline bool UserLoginRet::has_defaultgate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserLoginRet::set_has_defaultgate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserLoginRet::clear_has_defaultgate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserLoginRet::clear_defaultgate() {
  if (defaultgate_ != &::google::protobuf::internal::kEmptyString) {
    defaultgate_->clear();
  }
  clear_has_defaultgate();
}
inline const ::std::string& UserLoginRet::defaultgate() const {
  return *defaultgate_;
}
inline void UserLoginRet::set_defaultgate(const ::std::string& value) {
  set_has_defaultgate();
  if (defaultgate_ == &::google::protobuf::internal::kEmptyString) {
    defaultgate_ = new ::std::string;
  }
  defaultgate_->assign(value);
}
inline void UserLoginRet::set_defaultgate(const char* value) {
  set_has_defaultgate();
  if (defaultgate_ == &::google::protobuf::internal::kEmptyString) {
    defaultgate_ = new ::std::string;
  }
  defaultgate_->assign(value);
}
inline void UserLoginRet::set_defaultgate(const char* value, size_t size) {
  set_has_defaultgate();
  if (defaultgate_ == &::google::protobuf::internal::kEmptyString) {
    defaultgate_ = new ::std::string;
  }
  defaultgate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRet::mutable_defaultgate() {
  set_has_defaultgate();
  if (defaultgate_ == &::google::protobuf::internal::kEmptyString) {
    defaultgate_ = new ::std::string;
  }
  return defaultgate_;
}
inline ::std::string* UserLoginRet::release_defaultgate() {
  clear_has_defaultgate();
  if (defaultgate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defaultgate_;
    defaultgate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginRet::set_allocated_defaultgate(::std::string* defaultgate) {
  if (defaultgate_ != &::google::protobuf::internal::kEmptyString) {
    delete defaultgate_;
  }
  if (defaultgate) {
    set_has_defaultgate();
    defaultgate_ = defaultgate;
  } else {
    clear_has_defaultgate();
    defaultgate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string errorMsg = 15;
inline bool UserLoginRet::has_errormsg() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserLoginRet::set_has_errormsg() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserLoginRet::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserLoginRet::clear_errormsg() {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    errormsg_->clear();
  }
  clear_has_errormsg();
}
inline const ::std::string& UserLoginRet::errormsg() const {
  return *errormsg_;
}
inline void UserLoginRet::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void UserLoginRet::set_errormsg(const char* value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void UserLoginRet::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRet::mutable_errormsg() {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  return errormsg_;
}
inline ::std::string* UserLoginRet::release_errormsg() {
  clear_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormsg_;
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginRet::set_allocated_errormsg(::std::string* errormsg) {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    delete errormsg_;
  }
  if (errormsg) {
    set_has_errormsg();
    errormsg_ = errormsg;
  } else {
    clear_has_errormsg();
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestSMSCode

// optional int32 packet_id = 1 [default = 1007];
inline bool RequestSMSCode::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSMSCode::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSMSCode::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSMSCode::clear_packet_id() {
  packet_id_ = 1007;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 RequestSMSCode::packet_id() const {
  return packet_id_;
}
inline void RequestSMSCode::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// required string acc = 2;
inline bool RequestSMSCode::has_acc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSMSCode::set_has_acc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSMSCode::clear_has_acc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSMSCode::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& RequestSMSCode::acc() const {
  return *acc_;
}
inline void RequestSMSCode::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void RequestSMSCode::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void RequestSMSCode::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestSMSCode::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* RequestSMSCode::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestSMSCode::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string phoneNum = 3;
inline bool RequestSMSCode::has_phonenum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestSMSCode::set_has_phonenum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestSMSCode::clear_has_phonenum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestSMSCode::clear_phonenum() {
  if (phonenum_ != &::google::protobuf::internal::kEmptyString) {
    phonenum_->clear();
  }
  clear_has_phonenum();
}
inline const ::std::string& RequestSMSCode::phonenum() const {
  return *phonenum_;
}
inline void RequestSMSCode::set_phonenum(const ::std::string& value) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(value);
}
inline void RequestSMSCode::set_phonenum(const char* value) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(value);
}
inline void RequestSMSCode::set_phonenum(const char* value, size_t size) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestSMSCode::mutable_phonenum() {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  return phonenum_;
}
inline ::std::string* RequestSMSCode::release_phonenum() {
  clear_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phonenum_;
    phonenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestSMSCode::set_allocated_phonenum(::std::string* phonenum) {
  if (phonenum_ != &::google::protobuf::internal::kEmptyString) {
    delete phonenum_;
  }
  if (phonenum) {
    set_has_phonenum();
    phonenum_ = phonenum;
  } else {
    clear_has_phonenum();
    phonenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 smsType = 4;
inline bool RequestSMSCode::has_smstype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestSMSCode::set_has_smstype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestSMSCode::clear_has_smstype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestSMSCode::clear_smstype() {
  smstype_ = 0;
  clear_has_smstype();
}
inline ::google::protobuf::int32 RequestSMSCode::smstype() const {
  return smstype_;
}
inline void RequestSMSCode::set_smstype(::google::protobuf::int32 value) {
  set_has_smstype();
  smstype_ = value;
}

// -------------------------------------------------------------------

// Req2WebSMSRet

// required int32 reqSMSCode = 1;
inline bool Req2WebSMSRet::has_reqsmscode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Req2WebSMSRet::set_has_reqsmscode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Req2WebSMSRet::clear_has_reqsmscode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Req2WebSMSRet::clear_reqsmscode() {
  reqsmscode_ = 0;
  clear_has_reqsmscode();
}
inline ::google::protobuf::int32 Req2WebSMSRet::reqsmscode() const {
  return reqsmscode_;
}
inline void Req2WebSMSRet::set_reqsmscode(::google::protobuf::int32 value) {
  set_has_reqsmscode();
  reqsmscode_ = value;
}

// required bytes info = 2;
inline bool Req2WebSMSRet::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Req2WebSMSRet::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Req2WebSMSRet::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Req2WebSMSRet::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& Req2WebSMSRet::info() const {
  return *info_;
}
inline void Req2WebSMSRet::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void Req2WebSMSRet::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void Req2WebSMSRet::set_info(const void* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Req2WebSMSRet::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* Req2WebSMSRet::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Req2WebSMSRet::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserPhoneBinding

// optional int32 packet_id = 1 [default = 1009];
inline bool UserPhoneBinding::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPhoneBinding::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPhoneBinding::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPhoneBinding::clear_packet_id() {
  packet_id_ = 1009;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 UserPhoneBinding::packet_id() const {
  return packet_id_;
}
inline void UserPhoneBinding::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// required string acc = 2;
inline bool UserPhoneBinding::has_acc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPhoneBinding::set_has_acc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPhoneBinding::clear_has_acc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPhoneBinding::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& UserPhoneBinding::acc() const {
  return *acc_;
}
inline void UserPhoneBinding::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void UserPhoneBinding::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void UserPhoneBinding::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPhoneBinding::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* UserPhoneBinding::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPhoneBinding::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pwd = 3;
inline bool UserPhoneBinding::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserPhoneBinding::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserPhoneBinding::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserPhoneBinding::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& UserPhoneBinding::pwd() const {
  return *pwd_;
}
inline void UserPhoneBinding::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void UserPhoneBinding::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void UserPhoneBinding::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPhoneBinding::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* UserPhoneBinding::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPhoneBinding::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string deviceNum = 4;
inline bool UserPhoneBinding::has_devicenum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserPhoneBinding::set_has_devicenum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserPhoneBinding::clear_has_devicenum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserPhoneBinding::clear_devicenum() {
  if (devicenum_ != &::google::protobuf::internal::kEmptyString) {
    devicenum_->clear();
  }
  clear_has_devicenum();
}
inline const ::std::string& UserPhoneBinding::devicenum() const {
  return *devicenum_;
}
inline void UserPhoneBinding::set_devicenum(const ::std::string& value) {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  devicenum_->assign(value);
}
inline void UserPhoneBinding::set_devicenum(const char* value) {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  devicenum_->assign(value);
}
inline void UserPhoneBinding::set_devicenum(const char* value, size_t size) {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  devicenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPhoneBinding::mutable_devicenum() {
  set_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    devicenum_ = new ::std::string;
  }
  return devicenum_;
}
inline ::std::string* UserPhoneBinding::release_devicenum() {
  clear_has_devicenum();
  if (devicenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicenum_;
    devicenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPhoneBinding::set_allocated_devicenum(::std::string* devicenum) {
  if (devicenum_ != &::google::protobuf::internal::kEmptyString) {
    delete devicenum_;
  }
  if (devicenum) {
    set_has_devicenum();
    devicenum_ = devicenum;
  } else {
    clear_has_devicenum();
    devicenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phoneNum = 5;
inline bool UserPhoneBinding::has_phonenum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserPhoneBinding::set_has_phonenum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserPhoneBinding::clear_has_phonenum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserPhoneBinding::clear_phonenum() {
  if (phonenum_ != &::google::protobuf::internal::kEmptyString) {
    phonenum_->clear();
  }
  clear_has_phonenum();
}
inline const ::std::string& UserPhoneBinding::phonenum() const {
  return *phonenum_;
}
inline void UserPhoneBinding::set_phonenum(const ::std::string& value) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(value);
}
inline void UserPhoneBinding::set_phonenum(const char* value) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(value);
}
inline void UserPhoneBinding::set_phonenum(const char* value, size_t size) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPhoneBinding::mutable_phonenum() {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  return phonenum_;
}
inline ::std::string* UserPhoneBinding::release_phonenum() {
  clear_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phonenum_;
    phonenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPhoneBinding::set_allocated_phonenum(::std::string* phonenum) {
  if (phonenum_ != &::google::protobuf::internal::kEmptyString) {
    delete phonenum_;
  }
  if (phonenum) {
    set_has_phonenum();
    phonenum_ = phonenum;
  } else {
    clear_has_phonenum();
    phonenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 smsCode = 6;
inline bool UserPhoneBinding::has_smscode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserPhoneBinding::set_has_smscode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserPhoneBinding::clear_has_smscode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserPhoneBinding::clear_smscode() {
  smscode_ = 0;
  clear_has_smscode();
}
inline ::google::protobuf::int32 UserPhoneBinding::smscode() const {
  return smscode_;
}
inline void UserPhoneBinding::set_smscode(::google::protobuf::int32 value) {
  set_has_smscode();
  smscode_ = value;
}

// -------------------------------------------------------------------

// UserAliPayBinding

// optional int32 packet_id = 1 [default = 1011];
inline bool UserAliPayBinding::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserAliPayBinding::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserAliPayBinding::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserAliPayBinding::clear_packet_id() {
  packet_id_ = 1011;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 UserAliPayBinding::packet_id() const {
  return packet_id_;
}
inline void UserAliPayBinding::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// required string acc = 2;
inline bool UserAliPayBinding::has_acc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserAliPayBinding::set_has_acc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserAliPayBinding::clear_has_acc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserAliPayBinding::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& UserAliPayBinding::acc() const {
  return *acc_;
}
inline void UserAliPayBinding::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void UserAliPayBinding::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void UserAliPayBinding::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserAliPayBinding::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* UserAliPayBinding::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserAliPayBinding::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alipayAcc = 3;
inline bool UserAliPayBinding::has_alipayacc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserAliPayBinding::set_has_alipayacc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserAliPayBinding::clear_has_alipayacc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserAliPayBinding::clear_alipayacc() {
  if (alipayacc_ != &::google::protobuf::internal::kEmptyString) {
    alipayacc_->clear();
  }
  clear_has_alipayacc();
}
inline const ::std::string& UserAliPayBinding::alipayacc() const {
  return *alipayacc_;
}
inline void UserAliPayBinding::set_alipayacc(const ::std::string& value) {
  set_has_alipayacc();
  if (alipayacc_ == &::google::protobuf::internal::kEmptyString) {
    alipayacc_ = new ::std::string;
  }
  alipayacc_->assign(value);
}
inline void UserAliPayBinding::set_alipayacc(const char* value) {
  set_has_alipayacc();
  if (alipayacc_ == &::google::protobuf::internal::kEmptyString) {
    alipayacc_ = new ::std::string;
  }
  alipayacc_->assign(value);
}
inline void UserAliPayBinding::set_alipayacc(const char* value, size_t size) {
  set_has_alipayacc();
  if (alipayacc_ == &::google::protobuf::internal::kEmptyString) {
    alipayacc_ = new ::std::string;
  }
  alipayacc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserAliPayBinding::mutable_alipayacc() {
  set_has_alipayacc();
  if (alipayacc_ == &::google::protobuf::internal::kEmptyString) {
    alipayacc_ = new ::std::string;
  }
  return alipayacc_;
}
inline ::std::string* UserAliPayBinding::release_alipayacc() {
  clear_has_alipayacc();
  if (alipayacc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alipayacc_;
    alipayacc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserAliPayBinding::set_allocated_alipayacc(::std::string* alipayacc) {
  if (alipayacc_ != &::google::protobuf::internal::kEmptyString) {
    delete alipayacc_;
  }
  if (alipayacc) {
    set_has_alipayacc();
    alipayacc_ = alipayacc;
  } else {
    clear_has_alipayacc();
    alipayacc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string realName = 4;
inline bool UserAliPayBinding::has_realname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserAliPayBinding::set_has_realname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserAliPayBinding::clear_has_realname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserAliPayBinding::clear_realname() {
  if (realname_ != &::google::protobuf::internal::kEmptyString) {
    realname_->clear();
  }
  clear_has_realname();
}
inline const ::std::string& UserAliPayBinding::realname() const {
  return *realname_;
}
inline void UserAliPayBinding::set_realname(const ::std::string& value) {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  realname_->assign(value);
}
inline void UserAliPayBinding::set_realname(const char* value) {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  realname_->assign(value);
}
inline void UserAliPayBinding::set_realname(const char* value, size_t size) {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  realname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserAliPayBinding::mutable_realname() {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  return realname_;
}
inline ::std::string* UserAliPayBinding::release_realname() {
  clear_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = realname_;
    realname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserAliPayBinding::set_allocated_realname(::std::string* realname) {
  if (realname_ != &::google::protobuf::internal::kEmptyString) {
    delete realname_;
  }
  if (realname) {
    set_has_realname();
    realname_ = realname;
  } else {
    clear_has_realname();
    realname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RetrievePwd

// optional int32 packet_id = 1 [default = 1013];
inline bool RetrievePwd::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetrievePwd::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetrievePwd::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetrievePwd::clear_packet_id() {
  packet_id_ = 1013;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 RetrievePwd::packet_id() const {
  return packet_id_;
}
inline void RetrievePwd::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// required string acc = 2;
inline bool RetrievePwd::has_acc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetrievePwd::set_has_acc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetrievePwd::clear_has_acc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetrievePwd::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& RetrievePwd::acc() const {
  return *acc_;
}
inline void RetrievePwd::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void RetrievePwd::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void RetrievePwd::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RetrievePwd::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* RetrievePwd::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RetrievePwd::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string phoneNum = 3;
inline bool RetrievePwd::has_phonenum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetrievePwd::set_has_phonenum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetrievePwd::clear_has_phonenum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetrievePwd::clear_phonenum() {
  if (phonenum_ != &::google::protobuf::internal::kEmptyString) {
    phonenum_->clear();
  }
  clear_has_phonenum();
}
inline const ::std::string& RetrievePwd::phonenum() const {
  return *phonenum_;
}
inline void RetrievePwd::set_phonenum(const ::std::string& value) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(value);
}
inline void RetrievePwd::set_phonenum(const char* value) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(value);
}
inline void RetrievePwd::set_phonenum(const char* value, size_t size) {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  phonenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RetrievePwd::mutable_phonenum() {
  set_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    phonenum_ = new ::std::string;
  }
  return phonenum_;
}
inline ::std::string* RetrievePwd::release_phonenum() {
  clear_has_phonenum();
  if (phonenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phonenum_;
    phonenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RetrievePwd::set_allocated_phonenum(::std::string* phonenum) {
  if (phonenum_ != &::google::protobuf::internal::kEmptyString) {
    delete phonenum_;
  }
  if (phonenum) {
    set_has_phonenum();
    phonenum_ = phonenum;
  } else {
    clear_has_phonenum();
    phonenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 smsNum = 4;
inline bool RetrievePwd::has_smsnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RetrievePwd::set_has_smsnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RetrievePwd::clear_has_smsnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RetrievePwd::clear_smsnum() {
  smsnum_ = 0;
  clear_has_smsnum();
}
inline ::google::protobuf::int32 RetrievePwd::smsnum() const {
  return smsnum_;
}
inline void RetrievePwd::set_smsnum(::google::protobuf::int32 value) {
  set_has_smsnum();
  smsnum_ = value;
}

// required string newPwd = 5;
inline bool RetrievePwd::has_newpwd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RetrievePwd::set_has_newpwd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RetrievePwd::clear_has_newpwd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RetrievePwd::clear_newpwd() {
  if (newpwd_ != &::google::protobuf::internal::kEmptyString) {
    newpwd_->clear();
  }
  clear_has_newpwd();
}
inline const ::std::string& RetrievePwd::newpwd() const {
  return *newpwd_;
}
inline void RetrievePwd::set_newpwd(const ::std::string& value) {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  newpwd_->assign(value);
}
inline void RetrievePwd::set_newpwd(const char* value) {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  newpwd_->assign(value);
}
inline void RetrievePwd::set_newpwd(const char* value, size_t size) {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  newpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RetrievePwd::mutable_newpwd() {
  set_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    newpwd_ = new ::std::string;
  }
  return newpwd_;
}
inline ::std::string* RetrievePwd::release_newpwd() {
  clear_has_newpwd();
  if (newpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newpwd_;
    newpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RetrievePwd::set_allocated_newpwd(::std::string* newpwd) {
  if (newpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete newpwd_;
  }
  if (newpwd) {
    set_has_newpwd();
    newpwd_ = newpwd;
  } else {
    clear_has_newpwd();
    newpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BindingRet

// optional int32 packet_id = 1 [default = 1012];
inline bool BindingRet::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindingRet::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindingRet::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindingRet::clear_packet_id() {
  packet_id_ = 1012;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 BindingRet::packet_id() const {
  return packet_id_;
}
inline void BindingRet::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// optional int32 result = 2;
inline bool BindingRet::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindingRet::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindingRet::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindingRet::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BindingRet::result() const {
  return result_;
}
inline void BindingRet::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 optype = 3;
inline bool BindingRet::has_optype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindingRet::set_has_optype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindingRet::clear_has_optype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindingRet::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::google::protobuf::int32 BindingRet::optype() const {
  return optype_;
}
inline void BindingRet::set_optype(::google::protobuf::int32 value) {
  set_has_optype();
  optype_ = value;
}

// required int32 errorNum = 4;
inline bool BindingRet::has_errornum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BindingRet::set_has_errornum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BindingRet::clear_has_errornum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BindingRet::clear_errornum() {
  errornum_ = 0;
  clear_has_errornum();
}
inline ::google::protobuf::int32 BindingRet::errornum() const {
  return errornum_;
}
inline void BindingRet::set_errornum(::google::protobuf::int32 value) {
  set_has_errornum();
  errornum_ = value;
}

// -------------------------------------------------------------------

// Ch2LBindingRet

// required bytes upbInfo = 1;
inline bool Ch2LBindingRet::has_upbinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ch2LBindingRet::set_has_upbinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ch2LBindingRet::clear_has_upbinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ch2LBindingRet::clear_upbinfo() {
  if (upbinfo_ != &::google::protobuf::internal::kEmptyString) {
    upbinfo_->clear();
  }
  clear_has_upbinfo();
}
inline const ::std::string& Ch2LBindingRet::upbinfo() const {
  return *upbinfo_;
}
inline void Ch2LBindingRet::set_upbinfo(const ::std::string& value) {
  set_has_upbinfo();
  if (upbinfo_ == &::google::protobuf::internal::kEmptyString) {
    upbinfo_ = new ::std::string;
  }
  upbinfo_->assign(value);
}
inline void Ch2LBindingRet::set_upbinfo(const char* value) {
  set_has_upbinfo();
  if (upbinfo_ == &::google::protobuf::internal::kEmptyString) {
    upbinfo_ = new ::std::string;
  }
  upbinfo_->assign(value);
}
inline void Ch2LBindingRet::set_upbinfo(const void* value, size_t size) {
  set_has_upbinfo();
  if (upbinfo_ == &::google::protobuf::internal::kEmptyString) {
    upbinfo_ = new ::std::string;
  }
  upbinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ch2LBindingRet::mutable_upbinfo() {
  set_has_upbinfo();
  if (upbinfo_ == &::google::protobuf::internal::kEmptyString) {
    upbinfo_ = new ::std::string;
  }
  return upbinfo_;
}
inline ::std::string* Ch2LBindingRet::release_upbinfo() {
  clear_has_upbinfo();
  if (upbinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = upbinfo_;
    upbinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ch2LBindingRet::set_allocated_upbinfo(::std::string* upbinfo) {
  if (upbinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete upbinfo_;
  }
  if (upbinfo) {
    set_has_upbinfo();
    upbinfo_ = upbinfo;
  } else {
    clear_has_upbinfo();
    upbinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes brInfo = 2;
inline bool Ch2LBindingRet::has_brinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ch2LBindingRet::set_has_brinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ch2LBindingRet::clear_has_brinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ch2LBindingRet::clear_brinfo() {
  if (brinfo_ != &::google::protobuf::internal::kEmptyString) {
    brinfo_->clear();
  }
  clear_has_brinfo();
}
inline const ::std::string& Ch2LBindingRet::brinfo() const {
  return *brinfo_;
}
inline void Ch2LBindingRet::set_brinfo(const ::std::string& value) {
  set_has_brinfo();
  if (brinfo_ == &::google::protobuf::internal::kEmptyString) {
    brinfo_ = new ::std::string;
  }
  brinfo_->assign(value);
}
inline void Ch2LBindingRet::set_brinfo(const char* value) {
  set_has_brinfo();
  if (brinfo_ == &::google::protobuf::internal::kEmptyString) {
    brinfo_ = new ::std::string;
  }
  brinfo_->assign(value);
}
inline void Ch2LBindingRet::set_brinfo(const void* value, size_t size) {
  set_has_brinfo();
  if (brinfo_ == &::google::protobuf::internal::kEmptyString) {
    brinfo_ = new ::std::string;
  }
  brinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ch2LBindingRet::mutable_brinfo() {
  set_has_brinfo();
  if (brinfo_ == &::google::protobuf::internal::kEmptyString) {
    brinfo_ = new ::std::string;
  }
  return brinfo_;
}
inline ::std::string* Ch2LBindingRet::release_brinfo() {
  clear_has_brinfo();
  if (brinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brinfo_;
    brinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ch2LBindingRet::set_allocated_brinfo(::std::string* brinfo) {
  if (brinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete brinfo_;
  }
  if (brinfo) {
    set_has_brinfo();
    brinfo_ = brinfo;
  } else {
    clear_has_brinfo();
    brinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqWorldToken

// optional int32 packet_id = 1 [default = 1019];
inline bool ReqWorldToken::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqWorldToken::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqWorldToken::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqWorldToken::clear_packet_id() {
  packet_id_ = 1019;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 ReqWorldToken::packet_id() const {
  return packet_id_;
}
inline void ReqWorldToken::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// optional string acc = 2;
inline bool ReqWorldToken::has_acc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqWorldToken::set_has_acc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqWorldToken::clear_has_acc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqWorldToken::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& ReqWorldToken::acc() const {
  return *acc_;
}
inline void ReqWorldToken::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void ReqWorldToken::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void ReqWorldToken::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqWorldToken::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* ReqWorldToken::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqWorldToken::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqWorldTokenRet

// optional int32 packet_id = 1 [default = 1020];
inline bool ReqWorldTokenRet::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqWorldTokenRet::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqWorldTokenRet::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqWorldTokenRet::clear_packet_id() {
  packet_id_ = 1020;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 ReqWorldTokenRet::packet_id() const {
  return packet_id_;
}
inline void ReqWorldTokenRet::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// optional string acc = 2;
inline bool ReqWorldTokenRet::has_acc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqWorldTokenRet::set_has_acc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqWorldTokenRet::clear_has_acc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqWorldTokenRet::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& ReqWorldTokenRet::acc() const {
  return *acc_;
}
inline void ReqWorldTokenRet::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void ReqWorldTokenRet::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void ReqWorldTokenRet::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqWorldTokenRet::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* ReqWorldTokenRet::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqWorldTokenRet::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 3;
inline bool ReqWorldTokenRet::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqWorldTokenRet::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqWorldTokenRet::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqWorldTokenRet::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ReqWorldTokenRet::token() const {
  return *token_;
}
inline void ReqWorldTokenRet::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqWorldTokenRet::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqWorldTokenRet::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqWorldTokenRet::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ReqWorldTokenRet::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqWorldTokenRet::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestChargeOrder

// optional int32 packet_id = 1 [default = 1018];
inline bool RequestChargeOrder::has_packet_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestChargeOrder::set_has_packet_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestChargeOrder::clear_has_packet_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestChargeOrder::clear_packet_id() {
  packet_id_ = 1018;
  clear_has_packet_id();
}
inline ::google::protobuf::int32 RequestChargeOrder::packet_id() const {
  return packet_id_;
}
inline void RequestChargeOrder::set_packet_id(::google::protobuf::int32 value) {
  set_has_packet_id();
  packet_id_ = value;
}

// required string acc = 2;
inline bool RequestChargeOrder::has_acc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestChargeOrder::set_has_acc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestChargeOrder::clear_has_acc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestChargeOrder::clear_acc() {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    acc_->clear();
  }
  clear_has_acc();
}
inline const ::std::string& RequestChargeOrder::acc() const {
  return *acc_;
}
inline void RequestChargeOrder::set_acc(const ::std::string& value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void RequestChargeOrder::set_acc(const char* value) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(value);
}
inline void RequestChargeOrder::set_acc(const char* value, size_t size) {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  acc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestChargeOrder::mutable_acc() {
  set_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    acc_ = new ::std::string;
  }
  return acc_;
}
inline ::std::string* RequestChargeOrder::release_acc() {
  clear_has_acc();
  if (acc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_;
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestChargeOrder::set_allocated_acc(::std::string* acc) {
  if (acc_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_;
  }
  if (acc) {
    set_has_acc();
    acc_ = acc;
  } else {
    clear_has_acc();
    acc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 channelID = 3;
inline bool RequestChargeOrder::has_channelid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestChargeOrder::set_has_channelid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestChargeOrder::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestChargeOrder::clear_channelid() {
  channelid_ = 0;
  clear_has_channelid();
}
inline ::google::protobuf::int32 RequestChargeOrder::channelid() const {
  return channelid_;
}
inline void RequestChargeOrder::set_channelid(::google::protobuf::int32 value) {
  set_has_channelid();
  channelid_ = value;
}

// -------------------------------------------------------------------

// ChargeRet

// -------------------------------------------------------------------

// CheckChargeRet


// @@protoc_insertion_point(namespace_scope)

}  // namespace login2chk

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_login2chk_5fmsg_5ftype_2eproto__INCLUDED
